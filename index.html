<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="带着敬畏之心前进。">
<meta property="og:type" content="website">
<meta property="og:title" content="金梧的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="金梧的个人博客">
<meta property="og:description" content="带着敬畏之心前进。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="金梧的个人博客">
<meta name="twitter:description" content="带着敬畏之心前进。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>金梧的个人博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?69ccb5dd903e02644bdc9868ce3facf9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">金梧的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/04/FrameSync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="金梧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="金梧的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/04/FrameSync/" itemprop="url">在 Unity 中实现帧同步</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-04T00:00:00+08:00">
                2017-12-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/04/FrameSync/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/12/04/FrameSync/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/12/04/FrameSync/" class="leancloud_visitors" data-flag-title="在 Unity 中实现帧同步">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今年公司把重点放在手游上去了，我作为一个前端程序员，不得不紧跟节奏，于是开始了 Unity 的学习。不久前公司的游戏团队做了一款单人闯关的手游，老板在上线前想增加 PVP 的功能（类似于王者荣耀），但苦于团队没有做过网络游戏的经验，于是我又没有意外地接到了这个任务。在接下来的时间里，我经过各种查资料、写 Demo，最后决定使用帧同步技术来实现 PVP 对战功能。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>我们知道，在 PVP 网络游戏中，每个客户端都有可能操作一个或多个人物，可以移动、攻击、释放技能等等，在经过一系列计算处理后（比如打中了某个怪物），会在本客户端产生一个当前的状态，此时也需要知道其他客户端当前的状态，并且实时性要很高，这样才能保证此类游戏的可玩性。这种使得各个客户端表现一致的过程叫做同步，同步又分为状态同步和帧同步。</p>
<h2 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h2><p>状态同步顾名思义就是同步各个客户端的状态，可能过程不一定同步，但是能保证每一次操作后的状态是一致的。通过开发服务端程序，把用户的操作作为输入实时上传到服务端，服务端通过计算返回结果给各个客户端，这样的过程就是状态同步。</p>
<p>状态同步有几个特点：</p>
<ul>
<li>客户端只上传操作指令，但是接收所有客户端的状态信息。</li>
<li>整个游戏的逻辑全都在服务端，客户端只是展示的功能。</li>
<li>客户端反外挂能力强。</li>
<li>由服务端统一下发状态，不可能会有不同步的情况。</li>
<li>耗流量不稳定，数据传输量会随着游戏单位和单位信息的增多而增大。</li>
<li>开发效率低，由于整个游戏的逻辑都需要在服务端重新开发，某些引擎（比如 Unity）就完全无用了。</li>
</ul>
<h2 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h2><p>与状态同步不同的是，帧同步的服务端开发非常简单，只需要进行指令转发工作即可完成。客户端按照一定的帧速率（理解为逻辑帧，而不是客户端的渲染帧）去上传当前的操作指令，服务端将操作指令广播给所有客户端，当客户端收到指令后执行本地代码，如果输入的指令一致，计算的过程一致，那么计算的结果肯定是一致的，这样就能保证所有客户端的同步，这就是帧同步。</p>
<p>帧同步有几个特点：</p>
<ul>
<li>客户端只上传操作指令，也只接收操作指令。</li>
<li>整个游戏的逻辑在客户端，服务端没有客户端的状态信息。</li>
<li>客户端反外挂能力弱。</li>
<li>对客户端程序要求高，很容易出现不同步的情况，而且不容易查找。</li>
<li>耗流量低，数据传输量始终只有各个客户端的操作指令。</li>
<li>开发效率高，对于已经开发好的单机客户端，只需要按照帧同步的策略去修改部分代码即可。</li>
</ul>
<h1 id="帧同步实现的过程"><a href="#帧同步实现的过程" class="headerlink" title="帧同步实现的过程"></a>帧同步实现的过程</h1><p>通过上面的概念了解到帧同步其实就是客户端接收操作指令自行计算，使得结果一致从而保证同步。要实现帧同步，关键是要控制每个客户端的计算过程完全一致，因为起始状态一致，那么每一帧计算的结果肯定一致。帧同步还需要注意两个概念：逻辑帧和渲染帧。我们说的帧同步都是指逻辑帧同步，也就是说所有计算都是基于逻辑帧，渲染帧（Update 等）只作显示用。</p>
<p>传统的做法是每个客户端在一定时间内收集操作指令，以一定时间间隔（PVP 游戏一般为 50ms）上传操作指令，并且携带当前的帧编号（帧编号不断增加），服务端必须在收集到所有客户端的当前帧数据后才会下发，也就是会等待所有客户端正常上传操作指令才认为这一帧数据是正常的。这样做有个非常大的缺点，就是网络延迟永远等于延迟最高的那位玩家，这对于 PVP 这种实时性要求非常高的游戏来说是致命的，就游戏性而言也是不公平的。尽管有些开发者做了一些改进措施，比如超时机制，当服务端超过一定时间没有收到某个客户端的帧数据时，便舍弃这个客户端，直接广播数据给所有客户端。这样虽然能使得延迟效果好一些，但对网络要求较高，如果有一个客户端网络环境很差，那么每一帧数据都要等到这个超时才会下发，游戏肯定不会平滑了。</p>
<p>随着游戏技术的发展，帧同步也有了变化，出现了一种叫乐观帧的模式，它的核心流程和传统的帧同步完全相反，由服务端来控制帧速率（比如 50ms 增加一帧），客户端有了操作指令即时上传，空闲时间不用上传，服务端在一帧时间内把收集到的所有操作指令广播下去，客户端根据操作指令执行本地代码。这种模式的好处有几点：</p>
<ul>
<li>客户端不用在无操作指令的时候上传。</li>
<li>客户端不用控制帧速率（在不同平台客户端要想控制相同的速率也不是简单的事）。</li>
<li>不会因为某个客户端延迟而影响没有延迟的客户端，这点对于 PVP 游戏尤其重要。</li>
</ul>
<p>有了乐观帧同步，我们可以写一些实际代码来感受一下，下面是我写的 Demo 中的一些代码，功能就是仿照王者荣耀的玩法，对战双方的移动、攻击、扣血和复活，Demo 写的不是很精细，重点是做到客户端同步，而且还带了重连功能。</p>
<h2 id="如何接收帧指令"><a href="#如何接收帧指令" class="headerlink" title="如何接收帧指令"></a>如何接收帧指令</h2><p>乐观帧同步是由服务端控制帧速率的，但由于网络抖动等原因，不可能保证在客户端也能以相同时间间隔接收操作指令，我的做法就是把接收到的操作指令保存起来，然后在本地去以一定间隔取操作指令，执行完成后则删除。下面是我封装了一个处理帧指令的类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> SimpleJson;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogicFrame</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接收到的帧指令集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList frameOrderList = <span class="keyword">new</span> ArrayList ();</span><br><span class="line">    <span class="comment">// 记录当前执行的帧编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> frame = <span class="number">-1</span>; </span><br><span class="line">    <span class="comment">// 控制时间间隔</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastFrameTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> nextFrameWaitTime = <span class="number">0.05</span>f;</span><br><span class="line">    <span class="comment">// 需要分发逻辑帧的脚本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList methodList = <span class="keyword">new</span> ArrayList ();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList methodListTemp = <span class="keyword">new</span> ArrayList ();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList methodListDelete = <span class="keyword">new</span> ArrayList ();</span><br><span class="line">    <span class="comment">// 保存当前帧的玩家指令</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Dictionary&lt;<span class="keyword">int</span>, JsonObject&gt; playerOrder = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, JsonObject&gt; ();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 每隔一段时间执行一次 Loop() 函数，根据操作指令集合中剩余的数量来调整速度</span></span><br><span class="line">        <span class="keyword">float</span> now = Time.time;</span><br><span class="line">        <span class="keyword">int</span> frameCount = frameOrderList.Count;</span><br><span class="line">        <span class="keyword">if</span> (now - lastFrameTime &gt;= nextFrameWaitTime &amp;&amp; frameCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            lastFrameTime = now;</span><br><span class="line">            Loop ();</span><br><span class="line">            <span class="keyword">if</span> (frameCount == <span class="number">1</span>) &#123;</span><br><span class="line">                nextFrameWaitTime = <span class="number">0.05</span>f;</span><br><span class="line">            &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">frameCount == <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">                nextFrameWaitTime = <span class="number">0.038</span>f;</span><br><span class="line">            &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">frameCount &lt;= <span class="number">4</span></span>) </span>&#123;</span><br><span class="line">                nextFrameWaitTime = <span class="number">0.016</span>f;</span><br><span class="line">            &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">frameCount &lt;= <span class="number">16</span></span>) </span>&#123;</span><br><span class="line">                nextFrameWaitTime = <span class="number">0.0</span>f;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    Loop ();</span><br><span class="line">                &#125;</span><br><span class="line">                nextFrameWaitTime = <span class="number">0.0</span>f;</span><br><span class="line">            &#125;</span><br><span class="line">            nextFrameWaitTime = Mathf.Max (<span class="number">0</span>, nextFrameWaitTime - Time.deltaTime / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Loop</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 总是取第一条帧指令</span></span><br><span class="line">        JsonObject frameOrder = (JsonObject)frameOrderList [<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 记录当前执行的帧编号</span></span><br><span class="line">        frame = Convert.ToInt64 (frameOrder [<span class="string">"frame"</span>]);</span><br><span class="line">        <span class="comment">// 保存每个玩家的当前帧指令</span></span><br><span class="line">        JsonArray datas = (JsonArray)frameOrder [<span class="string">"datas"</span>];</span><br><span class="line">        playerOrder = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, JsonObject&gt; ();</span><br><span class="line">        <span class="keyword">foreach</span> (JsonObject data <span class="keyword">in</span> datas) &#123;</span><br><span class="line">            <span class="keyword">int</span> uid = Convert.ToInt32 (data [<span class="string">"uid"</span>]); </span><br><span class="line">            JsonObject userData = (JsonObject)data [<span class="string">"data"</span>];</span><br><span class="line">            playerOrder.Add (uid, userData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分发逻辑帧</span></span><br><span class="line">        Dispatch ();</span><br><span class="line">        <span class="comment">// 删除取出的指令</span></span><br><span class="line">        frameOrderList.RemoveAt (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispatch</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 先删除注销过的脚本</span></span><br><span class="line">        <span class="keyword">foreach</span> (Method method <span class="keyword">in</span> methodListDelete) &#123;</span><br><span class="line">            <span class="keyword">if</span> (methodList.Contains(method)) &#123;</span><br><span class="line">                methodList.Remove (method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        methodListDelete.Clear ();</span><br><span class="line">        <span class="comment">// 遍历集合，反射调用</span></span><br><span class="line">        methodList.AddRange(methodListTemp);</span><br><span class="line">        methodListTemp.RemoveRange (<span class="number">0</span>, methodListTemp.Count);</span><br><span class="line">        <span class="keyword">foreach</span> (Method method <span class="keyword">in</span> methodList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.methodInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            method.methodInfo.Invoke (method.mono, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JsonObject <span class="title">getFrameOrder</span> (<span class="params"><span class="keyword">int</span> uid</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (playerOrder.ContainsKey (uid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> playerOrder [uid];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span> (<span class="params">MonoBehaviour mono</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Method method = <span class="keyword">new</span> Method (mono, mono.GetType ().GetMethod (<span class="string">"FrameUpdate"</span>, BindingFlags.NonPublic | BindingFlags.Instance));</span><br><span class="line">        <span class="keyword">if</span> (methodList.Contains (method)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        methodListTemp.Add (method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Unregister</span> (<span class="params">MonoBehaviour mono</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Method method <span class="keyword">in</span> methodList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.mono.Equals (mono)) &#123;</span><br><span class="line">                methodListDelete.Add (method);    </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Method</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> MonoBehaviour mono;</span><br><span class="line">        <span class="keyword">public</span> MethodInfo methodInfo;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Method</span> (<span class="params">MonoBehaviour mono, MethodInfo methodInfo</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mono = mono;</span><br><span class="line">            <span class="keyword">this</span>.methodInfo = methodInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码首先在 Update 里面做了一个循环，会根据当前操作指令集合中剩余的数量调整间隔时间。可以看出数量越多速度会越快，设置出现了连续执行 10 次的情况，这是为了对抗网络延迟，如果某段时间网络延迟了一下，Loop() 函数执行速度会增加（游戏中的表现就是加速），直至让集合清空，由于服务端是定时下发操作指令，这样处理不至于让操作指令集合越堆越多，导致客户端表现明显的延迟。还可以看到如果集合为空，将不会执行 Loop() 函数。由于帧同步是由逻辑帧驱动的，如果逻辑帧停止那么游戏表现也是停止，逻辑帧的间隔时间也会影响游戏的速度。</p>
<p>关于 Loop() 函数，应该可以说是帧同步的核心了，我一开始的做法是直接在里面进行计算，哪个地方需要，就调用哪个函数。但受到 Unity 的影响，发现它的每个过程都是以回调函数实现的，比如 Update，而且不带任何参数，如果需要取得某个参数，通过其他静态函数获取，比如获取鼠标按键。之后我也效仿这个设计，通过反射获取脚本的 FrameUpdate() 函数，然后在 Loop() 函数中调用，在调用 FrameUpdate() 函数前会把当前帧的操作指令保存起来，可以通过 getFrameOrder() 函数获取某个玩家当前帧的操作指令。</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>有了上面封装的类，我们可以实现一个关于物体移动的类，由于客户端的所有表现都需要逻辑驱动，所以不只是人物移动依赖 FrameUpdate() 函数，游戏中的飞行道具（如远程英雄攻击）也需要依赖 FrameUpdate()，我们可以写一个通用的类，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogicFrameMove</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要移动的对象</span></span><br><span class="line">    <span class="keyword">public</span> GameObject mover;</span><br><span class="line">    <span class="comment">// 移动速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> speed;</span><br><span class="line">    <span class="comment">// 当前帧的起始位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> currPosition;</span><br><span class="line">    <span class="comment">// 目标位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> targetPosition;</span><br><span class="line">    <span class="comment">// 上一次的目标位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastTargetPosition;</span><br><span class="line">    <span class="comment">// 预测的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> forecastPosition;</span><br><span class="line">    <span class="comment">// 当前帧的人物移动的真实速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> speedReal;</span><br><span class="line">    <span class="comment">// 是否是预测阶段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> isForecast = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 是否正在移动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> isMove = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 当前帧的移动是否是新的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> isNewPosition = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 移动动画相关</span></span><br><span class="line">    <span class="keyword">private</span> Animation animation;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> idleAnimationName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> moveAnimationName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> isNormalAnimation = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogicFrameMove</span>(<span class="params">GameObject mover, <span class="keyword">float</span> speed, Vector3 currPosition</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mover = mover;</span><br><span class="line">        <span class="keyword">this</span>.speed = speed;</span><br><span class="line">        <span class="keyword">this</span>.currPosition = currPosition;</span><br><span class="line">        targetPosition = Vector3.zero;</span><br><span class="line">        lastTargetPosition = Vector3.zero;</span><br><span class="line">        forecastPosition = Vector3.zero;</span><br><span class="line">        speedReal = speed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartMove</span>(<span class="params"><span class="keyword">float</span> vx, <span class="keyword">float</span> vy, <span class="keyword">float</span> vz</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 计算下一步应该要走的位置</span></span><br><span class="line">        Vector3 moveVector = <span class="keyword">new</span> Vector3 (vx, vy, vz);</span><br><span class="line">        targetPosition = currPosition + moveVector * <span class="number">0.05</span>f * speed;</span><br><span class="line">        currPosition = targetPosition;</span><br><span class="line">        <span class="comment">// 调整真实的移动速度</span></span><br><span class="line">        speedReal = Vector3.Distance(mover.transform.position, targetPosition) / <span class="number">0.05</span>f;</span><br><span class="line">        <span class="comment">// 计算一个预测的位置</span></span><br><span class="line">        forecastPosition = targetPosition + moveVector * <span class="number">0.05</span>f * speed;</span><br><span class="line">        <span class="comment">// 正在移动的标志</span></span><br><span class="line">        isMove = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetPosition == Vector3.zero) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否是新的位置</span></span><br><span class="line">        <span class="keyword">if</span> (lastTargetPosition == targetPosition) &#123;</span><br><span class="line">            isNewPosition = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isNewPosition = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTargetPosition = targetPosition;</span><br><span class="line">        <span class="comment">// 正常移动并判断是否需要预测位置</span></span><br><span class="line">        <span class="keyword">if</span> (isNewPosition) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isForecast) &#123;</span><br><span class="line">                mover.transform.LookAt (targetPosition);</span><br><span class="line">            &#125;</span><br><span class="line">            mover.transform.position = Vector3.MoveTowards (mover.transform.position, targetPosition, Time.deltaTime * speedReal);</span><br><span class="line">            isForecast = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isForecast) &#123;</span><br><span class="line">                mover.transform.LookAt (targetPosition);</span><br><span class="line">                mover.transform.position = Vector3.MoveTowards (mover.transform.position, targetPosition, Time.deltaTime * speedReal);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mover.transform.position == targetPosition) &#123;</span><br><span class="line">                isForecast = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 预测阶段需要走到预测的位置</span></span><br><span class="line">        <span class="keyword">if</span> (isForecast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (forecastPosition != Vector3.zero) &#123;</span><br><span class="line">                <span class="comment">// 只有移动状态才会走预测位置，如果在预测阶段停止移动则马上停</span></span><br><span class="line">                <span class="keyword">if</span> (isMove) &#123;</span><br><span class="line">                    mover.transform.LookAt (forecastPosition);</span><br><span class="line">                    mover.transform.position = Vector3.MoveTowards (mover.transform.position, forecastPosition, Time.deltaTime * speedReal);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动动画</span></span><br><span class="line">        MoveAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MoveAnimation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (animation == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isMove) &#123;</span><br><span class="line">            isNormalAnimation = <span class="literal">true</span>;</span><br><span class="line">            animation.Play (moveAnimationName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isNormalAnimation) &#123;</span><br><span class="line">                animation.Play (idleAnimationName);</span><br><span class="line">                isNormalAnimation = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopMove</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        isMove = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAnimation</span>(<span class="params">Animation animation, <span class="keyword">string</span> idleAnimationName, <span class="keyword">string</span> moveAnimationName</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.animation = animation;</span><br><span class="line">        <span class="keyword">this</span>.idleAnimationName = idleAnimationName;</span><br><span class="line">        <span class="keyword">this</span>.moveAnimationName = moveAnimationName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码关键是 StartMove() 函数，计算目标位置和预测位置，这个函数在逻辑帧中执行。目标位置是根据给定和速度朝着给定的方向朝前走 50ms 计算出来的，而预测位置则是朝前走 100ms。为什么要有个预测位置？我们知道网络延迟肯定是有的，那么不可能保证在这一帧执行完之前下一帧数据会按时到达，对于其他操作比如攻击影响倒是不大，但对于移动这种连续性的动作，如果严格按照逻辑帧驱动可能表现得不是很平滑，那么我们就需要一个预测位置。在新的移动位置没有计算出来时先朝着预测位置走去，如果此时新的位置计算出来，再朝新位置走去，这样也不会导致结果不一致。</p>
<p>剩下的 Move() 函数就是真正的移动操作了，这个方法需要放在渲染帧中执行，它与逻辑帧无关，它总是朝着计算好的位置走就对了。还有一个 StopMove() 方法停止移动和 SetAnimation() 方法来控制移动过程中的动画，这个函数应该根据项目使用的动画系统有所变化。</p>
<p>有了上面的代码，我们可以对任意物体进行移动，比如现在要对玩家射出的子弹进行移动，用法如下:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> SimpleJson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Projectile</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 飞行道具的飞行速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> speed;</span><br><span class="line">    <span class="comment">// 移动相关</span></span><br><span class="line">    <span class="keyword">private</span> LogicFrameMove mover;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mover = <span class="keyword">new</span> LogicFrameMove (gameObject, speed, transform.position);</span><br><span class="line">        <span class="comment">// 注册逻辑帧分发的回调函数</span></span><br><span class="line">        LogicFrame.Register (<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 注销逻辑帧分发的回调函数</span></span><br><span class="line">        LogicFrame.Unregister (<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FrameUpdate</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 按照当前方向计算目标位置和预测位置</span></span><br><span class="line">        Vector3 moveVector = <span class="keyword">new</span> Vector3 (transform.forward.x, transform.forward.y, transform.forward.z);</span><br><span class="line">        mover.StartMove (moveVector.x, moveVector.y, moveVector.z);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 物体移动</span></span><br><span class="line">        mover.Move ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就非常简单了，由于子弹产生后方向不会改变，所以只需要在 FrameUpdate() 里面不停地按照当前的方向计算位置就对了，然后在 Update 去移动，实现逻辑帧与渲染帧的分离。其他类型的移动大体一样，只不过方向可能随时会发生变化，比如人物移动摇杆不停变化，这里不再贴代码。</p>
<h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>攻击的实现比起移动就非常简单了，只需要在 FrameUpdate() 中接收操作指令，进行相应的处理即可，由于所有客户端在接到攻击指令时是同一逻辑帧，那么只要代码一样，产生的结果肯定也一致。</p>
<p>但我在开发过程中遇到一个问题，就是我在攻击后会有一些判断，如果有敌方玩家在攻击范围内，近程英雄会对其造成伤害，远程英雄会放出飞行道具，这里我是使用协程实现的。一开始觉得协程没有问题，后来测试出来在某些情况下可能不同步，比如如果游戏速度变化较大（根据网络情况自动调整，前面有说到），会造成受伤害的帧编号不一致，最后会导致死亡时间不一致，这样会由于蝴蝶效应产生更多意想不到的不同步。</p>
<p>所以针对这类和时间相关的（比如协程）在帧同步中应该禁止使用，应该严格按照逻辑帧来判断，比如攻击出手后 1s 放出飞行道具，那么就应该是在接收到攻击指令的那一帧开始停顿 20 帧（逻辑停顿）再放出飞行道具，针对这点我写了几个函数，可以实现延迟调用某个函数，这个函数也必须在 FrameUpdate() 函数里面使用，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟调用函数相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList methodDelayList = <span class="keyword">new</span> ArrayList ();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList methodDelayListTemp = <span class="keyword">new</span> ArrayList ();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InvokeDelay</span> (<span class="params">MonoBehaviour mono, <span class="keyword">float</span> delay, <span class="keyword">string</span> methodName, <span class="keyword">object</span>[] parameters</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> frame = (<span class="keyword">int</span>)(delay / <span class="number">0.05</span>f);</span><br><span class="line">    InvokeDelayByFrame (mono, frame, methodName, parameters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InvokeDelayByFrame</span> (<span class="params">MonoBehaviour mono, <span class="keyword">int</span> frame, <span class="keyword">string</span> methodName, <span class="keyword">object</span>[] parameters</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Method method = <span class="keyword">new</span> Method (mono, mono.GetType ().GetMethod (methodName, BindingFlags.NonPublic | BindingFlags.Instance));</span><br><span class="line">    methodDelayListTemp.Add (<span class="keyword">new</span> MethodDelay (method, parameters, frame));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">MethodDelay</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Method method;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span>[] parameters;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> currFrame;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> frame;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodDelay</span> (<span class="params">Method method, <span class="keyword">object</span>[] parameters, <span class="keyword">int</span> frame</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.parameters = parameters;</span><br><span class="line">        <span class="keyword">this</span>.currFrame = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.frame = frame;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Invoke</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArrayList deleteList = <span class="keyword">new</span> ArrayList ();</span><br><span class="line">    methodDelayList.AddRange (methodDelayListTemp);</span><br><span class="line">    methodDelayListTemp.RemoveRange (<span class="number">0</span>, methodDelayListTemp.Count);</span><br><span class="line">    <span class="keyword">foreach</span> (MethodDelay methodDelay <span class="keyword">in</span> methodDelayList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (methodDelay.method.methodInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">            deleteList.Add (methodDelay);</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 集合中的函数每一帧计数器加一，达到条件后反射调用</span></span><br><span class="line">        <span class="keyword">if</span> (methodDelay.currFrame == methodDelay.frame) &#123;</span><br><span class="line">            methodDelay.method.methodInfo.Invoke (methodDelay.method.mono, methodDelay.parameters);</span><br><span class="line">            deleteList.Add (methodDelay);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            methodDelay.currFrame++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (MethodDelay delete <span class="keyword">in</span> deleteList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (methodDelayList.Contains (delete)) &#123;</span><br><span class="line">            methodDelayList.Remove (delete);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Loop</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 延迟调用函数</span></span><br><span class="line">    Invoke ();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码很简单，首先根据传入的停顿时间计算应该停顿的帧数，然后将相关信息加入集合，在 Loop() 函数中遍历集合，每一次调用会增加当前帧数，当达到延时条件则反射调用，调用后即刻删除。</p>
<p>有了这几个函数，可以很轻松地实现攻击一段时间后作出反应，比如进程英雄在打中敌方英雄时使其受到伤害，使用方法如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FrameUpdate</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 取当前帧的指令，并进行相应的计算</span></span><br><span class="line">    JsonObject frameOrder = LogicFrame.getFrameOrder (uid);</span><br><span class="line">    <span class="keyword">if</span> (frameOrder != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == Global.Frame_Attack) &#123; <span class="comment">// 攻击</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 一秒后会对 aimId 玩家造成伤害</span></span><br><span class="line">            <span class="keyword">float</span> delay = <span class="number">1.0</span>f;</span><br><span class="line">            LogicFrame.InvokeDelay (<span class="keyword">this</span>, delay, <span class="string">"AttackHit"</span>, <span class="keyword">new</span> <span class="keyword">object</span>[]&#123;aimId&#125;);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AttackHit</span> (<span class="params"><span class="keyword">int</span> aimId</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对 aimId 玩家造成 200 点伤害</span></span><br><span class="line">    Damage (aimId, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="死亡、重生"><a href="#死亡、重生" class="headerlink" title="死亡、重生"></a>死亡、重生</h2><p>当某个玩家血量为 0 时，则判断其死亡，进入死亡倒计时，倒计时结束后重生，这些过程由于是不通知服务端的，完全靠客户端执行本地代码，所以也要严格按照逻辑帧驱动的方法写代码，否则容易造成不同步。比如重生倒计时，需要结合上面写的延时函数实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rebornTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Damage</span> (<span class="params"><span class="keyword">int</span> aimId, <span class="keyword">int</span> damageHp</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 被伤害的人</span></span><br><span class="line">    Player aimPlayer = Global.entity [aimId].GetComponent&lt;Player&gt; ();</span><br><span class="line">    <span class="comment">// 扣血</span></span><br><span class="line">    aimPlayer.blood.currValue -= damageHp;</span><br><span class="line">    <span class="comment">// 死亡</span></span><br><span class="line">    <span class="keyword">if</span> (aimPlayer.blood.currValue &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        aimPlayer.blood.currValue = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 开始重生倒计时</span></span><br><span class="line">        LogicFrame.InvokeDelayByFrame(aimPlayer, <span class="number">0.0</span>f, <span class="string">"RebornCountDown"</span>, <span class="keyword">new</span> <span class="keyword">object</span>[]&#123;time, aimId&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RebornCountDown</span> (<span class="params"><span class="keyword">int</span> time, <span class="keyword">int</span> aimId</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reborn (time, aimId);</span><br><span class="line">    <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        rebornTime = time - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 每隔一秒调用自身，当倒计时完成后退出</span></span><br><span class="line">        LogicFrame.InvokeDelay (<span class="keyword">this</span>, <span class="number">1.0</span>f, <span class="string">"RebornCountDown"</span>, <span class="keyword">new</span> <span class="keyword">object</span>[]&#123;rebornTime, aimId&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reborn</span> (<span class="params"><span class="keyword">int</span> time, <span class="keyword">int</span> aimId</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 重生完成</span></span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>死亡和重生也需要保证严格的同步，即在哪一帧死亡，在哪一帧重生，只要严格按照逻辑帧驱动，就不会出问题。</p>
<h1 id="关于定点数"><a href="#关于定点数" class="headerlink" title="关于定点数"></a>关于定点数</h1><p>如果使用帧同步开发手游，还要注意在不同平台（Android 和 IOS）下浮点数的精度差异，可能会造成计算的结果不同，要解决这个问题也很简单，使用定点数代替浮点数进行计算，关于定点数我在 Github 上找到一个库很好用，附上地址：<a href="https://github.com/Prince-Ling/LogicPhysics/" target="_blank" rel="noopener">https://github.com/Prince-Ling/LogicPhysics/</a>，使用方法就不再赘述。</p>
<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p>写了这么多代码，我把我写的 Demo 效果贴个动态图感受一下。</p>
<img src="/2017/12/04/FrameSync/gif01.gif">
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用帧同步技术是开发 PVP 必备的，但要使用好也是有一定难度的，要保证完全的同步是不太可能的（王者荣耀都有不同步的情况），但我们在开发中应当尽量避免不同步的操作，做到以下几点就能很好地避免不同步产生：</p>
<ul>
<li>游戏中关于计算都需要在 FrameUpdate() 函数中，只有渲染时才使用 Unity 自带的回调函数，如 Update()、FixedUpdate() 等。</li>
<li>禁止使用协程</li>
<li>禁止使用和时间相关的函数计算，比如 Time.time、Time.deltaTime 等，应该使用当前帧编号*帧间隔时间来计算。</li>
<li>游戏在不同平台运行时可能会由于浮点数的精度差异造成不同步，可以使用定点数解决这一问题。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/19/EventBus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="金梧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="金梧的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/19/EventBus/" itemprop="url">深入解读 EventBus 3.0 源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-19T00:00:00+08:00">
                2017-09-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/19/EventBus/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/09/19/EventBus/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/09/19/EventBus/" class="leancloud_visitors" data-flag-title="深入解读 EventBus 3.0 源码">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://greenrobot.org/eventbus/" target="_blank" rel="noopener">EventBus</a> 是一款非常优秀的 Android 事件订阅/发布框架，可以非常快速、简洁地实现组件间的通信，并且高度解耦。大致思想就是一个发布者在发布了事件后，所有订阅了这个类型事件的订阅者都可以接收到事件。本人本着刨根问底的优良传统，果断下载了一份源码（<a href="https://github.com/greenrobot/EventBus/" target="_blank" rel="noopener">源码地址：https://github.com/greenrobot/EventBus/</a>）进行学习，下面将按照使用的过程来解读源码。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>首先在对应模块的 build.gradle 里面配置：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'org.greenrobot:eventbus:3.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取实例"><a href="#获取实例" class="headerlink" title="获取实例"></a>获取实例</h2><p>在使用之前需要获取一个 EventBus 的实例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault();</span><br></pre></td></tr></table></figure>
<h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>订阅者需要订阅操作才能接受到事件，订阅代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>在合适的地方调用此方法，注意要和取消订阅方法成对出现。</p>
<h2 id="订阅方法"><a href="#订阅方法" class="headerlink" title="订阅方法"></a>订阅方法</h2><p>订阅者在订阅后需要实现一个订阅方法来接收发布者发布的事件，使用 @Subscribe 注解即可，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">event</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里处理业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 @Subscribe 注解有三个参数可以设置，也可以不设置使用默认值：</p>
<ul>
<li>threadMode：一个枚举类型，表示方法执行的线程，有四个值可选：ThreadMode.POSTING（默认值）、ThreadMode.MAIN、ThreadMode.BACKGROUND、ThreadMode.ASYNC。ThreadMode.POSTING 表示方法执行的线程和发布者发布消息时所在线程一致；ThreadMode.MAIN 表示无论发布者发布消息时是哪个线程，方法都将在 Android 主线程（也即UI线程）中被调用；ThreadMode.BACKGROUND 表示当发布者发布消息的线程不是主线程时，方法将会在一个単例的后台线程执行；ThreadMode.ASYNC 表示方法将会在一个新的后台线程执行，既不是主线程，也不是发布者发布消息的线程</li>
<li>sticky：表示是否接受粘性事件，默认为 false，如果设置为 true，则可以在发送粘性事件之后在进行订阅操作，依然可以接收事件</li>
<li>priority：表示事件的优先级，默认为 0，值越大优先级越大</li>
<li>方法参数：表示事件的类型，有且仅有一个参数</li>
</ul>
<h2 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h2><p>发布者在需要的地方发布事件，订阅了相同事件类型的订阅者便可以接收到，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(<span class="string">"Test"</span>);</span><br></pre></td></tr></table></figure>
<p>也可以发送粘性事件，如果在注解中指定 sticky 为 true，则可以延迟接收事件（先发布事件再订阅，在订阅的时候接收到事件），代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(<span class="string">"Test"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="移除粘性事件"><a href="#移除粘性事件" class="headerlink" title="移除粘性事件"></a>移除粘性事件</h2><p>如果不想接收某个粘性事件而粘性事件已经发布，则可以通过移除操作将其移除，代码如下（MessageEvent 是某个事件类型）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageEvent stickyEvent = EventBus.getDefault().getStickyEvent(MessageEvent.class);</span><br><span class="line"><span class="keyword">if</span>(stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    EventBus.getDefault().removeStickyEvent(stickyEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h2><p>订阅者如果不想再接收事件，需要进行取消订阅操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<h2 id="运行加速"><a href="#运行加速" class="headerlink" title="运行加速"></a>运行加速</h2><p>EventBus 提供了一个选项用于加速，首先在对应模块的 build.gradle 里面配置：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    annotationProcessor <span class="string">'org.greenrobot:eventbus-annotation-processor:3.0.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        eventBusIndex <span class="string">"com.example.myapp.MyEventBusIndex"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 com.example.myapp.MyEventBusIndex 是一个自动生成的索引类，类名可以自定义，然后在获取实例的时候改成如下代码便可实现加速：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).build();</span><br></pre></td></tr></table></figure>
<h1 id="获取实例源码解析"><a href="#获取实例源码解析" class="headerlink" title="获取实例源码解析"></a>获取实例源码解析</h1><p>在使用 EventBus 之前要获取实例，我们先来看看 getDefault() 方法及其相关方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder(); <span class="comment">// EventBusBuilder 的默认对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance; <span class="comment">// 单例模式的对象，使用 volatile 关键字保证多线程同时操作 defaultInstance 时其成员变量不会出现不一致的问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</span><br><span class="line">    backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">    asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">    subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">    logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">    sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">    sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">    throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">    eventInheritance = builder.eventInheritance;</span><br><span class="line">    executorService = builder.executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了一个単例模式获取实例，并且最终会调用一个带有 EventBusBuilder 参数的构造方法，里面进行各种参数初始化。我们先不管这些参数的具体含义是什么，首先去看一看 EventBusBuilder 是什么样的，有这样两个方法返回 EventBus 的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">installDefaultEventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (EventBus.defaultInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Default instance already exists."</span> + <span class="string">" It may be only set once before it's used the first time to ensure consistent behavior."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        EventBus.defaultInstance = build();</span><br><span class="line">        <span class="keyword">return</span> EventBus.defaultInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventBus <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventBus(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们大概知道了它使用了建造者模式，通过 EventBusBuilder 初始化各种参数，然后给 EventBus 赋值。因此获取实例其实有很好几种方式，如下：</p>
<ul>
<li>获取默认配置的単例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault();</span><br></pre></td></tr></table></figure>
<ul>
<li>获取默认配置的新的实例，这种方式不能执行两次</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().installDefaultEventBus();</span><br></pre></td></tr></table></figure>
<ul>
<li>获取新的实例，并且可以根据需求进行参数设置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().build();</span><br></pre></td></tr></table></figure>
<h1 id="订阅源码解析"><a href="#订阅源码解析" class="headerlink" title="订阅源码解析"></a>订阅源码解析</h1><p>订阅者要想接收发布者发布的事件，首先要进行订阅操作，首先我们来看看 register() 方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SubscriberMethodFinder subscriberMethodFinder;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到指定订阅者的订阅方法，转换为 SubscriberMethod 对象集合</span></span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个 SubscriberMethod 对象进行订阅操作</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做了两件事情：寻找订阅方法并转换为 SubscriberMethod 对象集合、遍历 SubscriberMethod 对象集合进行订阅操作。</p>
<p>这里出现了一个名为 SubscriberMethod 的类，它其实就是对应订阅方法的实体类，里面保存了订阅方法的信息，其主要属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Method method; <span class="comment">// 订阅方法的 Method 对象</span></span><br><span class="line"><span class="keyword">final</span> ThreadMode threadMode; <span class="comment">// 线程模型，对应 @Subscriber 注解中的 ThreadMode 的值</span></span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt; eventType; <span class="comment">// 事件类型，订阅方法的参数的 Class 对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> priority; <span class="comment">// 事件的优先级，对应 @Subscriber 注解中的 priority 的值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> sticky; <span class="comment">// 是否接受粘性事件，对应 @Subscriber 注解中的 sticky 的值</span></span><br><span class="line">String methodString; <span class="comment">// 订阅方法的名称</span></span><br></pre></td></tr></table></figure>
<h2 id="查找订阅方法"><a href="#查找订阅方法" class="headerlink" title="查找订阅方法"></a>查找订阅方法</h2><p>订阅的第一步是查找订阅方法，这里使用了一个叫 SubscriberMethodFinder 的对象方法 findSubscriberMethods() 进行查找操作，可以发现之前在获取 EventBus 实例的时候对 SubscriberMethodFinder 进行了初始化操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    ...</span><br><span class="line">    subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的三个参数取的是 EventBuilder 的参数，代表的含义如下：</p>
<ul>
<li>subscriberInfoIndexes：List<subscriberinfoindex>——订阅对象的索引集合，默认值为 null</subscriberinfoindex></li>
<li>strictMethodVerification：是否进行严格的方法验证，默认值为 false</li>
<li>ignoreGeneratedIndex：是否忽略注解处理器生成的自定义类，默认值为 false</li>
</ul>
<p>这些参数都可以在创建 EventBus 实例的时候通过 EventBusBuilder 设置，我们先跳过具体的用途，到了该用到的时候自然就会明白。</p>
<p>接下来看看 findSubscriberMethods() 方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 从缓存从读取要找的对象集合，如果有直接返回</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否忽略注解处理器生成的自定义类</span></span><br><span class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">        <span class="comment">// 利用反射机制获取订阅者的 SubscriberMethod 集合</span></span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从注解处理器生成的自定义类中获取订阅者的 SubscriberMethod 集合</span></span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果订阅者的 SubscriberMethod 集合为空，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则存入缓存</span></span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的目的很明确，即把订阅者的所有订阅方法转换成 SubscriberMethod 对象集合，转换过程通过 ignoreGeneratedIndex 字段判断使用哪种方式。从代码中还可以看出我们在使用过程中，如果一个类里面进行了注册操作而没有实现订阅方法话就会抛出异常。并且代码中使用了缓存，提高了程序运行效率。</p>
<h3 id="反射查找"><a href="#反射查找" class="headerlink" title="反射查找"></a>反射查找</h3><p>我们先看忽略注解处理器的情况，利用反射机制获取订阅者的 SubscriberMethod 集合，findUsingReflection() 方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 FindState 实例并初始化</span></span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里有一个循环，只要 FindState 的 clazz 对象不为 null，将会一直循环，其实这里就是把包括 clazz 本身及其所有父类都遍历了</span></span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过反射查找订阅方法</span></span><br><span class="line">        findUsingReflectionInSingleClass(findState);</span><br><span class="line">        <span class="comment">// 移动至父类查找</span></span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回找到的 SubscriberMethod 对象集合并做了一些释放资源的操作</span></span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法虽然精简，但却包含了几个关键的方法，这几个方法是整个查找订阅方法过程中的主要逻辑判断和处理。</p>
<p>首先我们来看一看 FindState，这是一个内部类，作用是保存查找到的 SubscriberMethod 对象集合的状态，通俗地说就是记录查找 SubscriberMethod 对象集合过程中产生的一些数据。这里我们先看两个方法，这两个方法是相互呼应的，一个是生成 FindState 实例，一个是 FindState 中保存的 SubscriberMethod 对象集合返回并且还原 FindState 的状态，下面来看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FindState[] FIND_STATE_POOL = <span class="keyword">new</span> FindState[POOL_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">            FindState state = FIND_STATE_POOL[i];</span><br><span class="line">            <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                FIND_STATE_POOL[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FindState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">    <span class="comment">// FindState 状态还原</span></span><br><span class="line">    findState.recycle();</span><br><span class="line">    <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                FIND_STATE_POOL[i] = findState;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了对象池的思维，需要 FindState 对象时从对象池去取，没有对象则新建实例返回。同样地，当 FindState 对象用完后把其状态还原放入对象池中。这样做，可以在并发编程时减少对象实例化的次数，达到对象复用的目的。</p>
<p>接着看 findUsingReflection() 方法，首先调用了 FindState 的 initForSubscriber() 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; subscriberClass; <span class="comment">// 不明觉厉</span></span><br><span class="line">Class&lt;?&gt; clazz; <span class="comment">// 订阅者的 Class 对象 </span></span><br><span class="line"><span class="keyword">boolean</span> skipSuperClasses; <span class="comment">// 是否跳过父类的查找</span></span><br><span class="line">SubscriberInfo subscriberInfo; <span class="comment">// 订阅方法消息的接口，此参数与注解处理器生成的索引类有关</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initForSubscriber</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subscriberClass = clazz = subscriberClass;</span><br><span class="line">    skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">    subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我一直有个没明白的地方，就是 subscriberClass 这个参数有什么用，我发现代码里面没有什么地方用到了，并且将其注释再运行程序没有任何问题，所以我们先忽略这个参数。初始化完成后就是循环查找订阅者本身及其所有父类的订阅方法了，有两个方法：findUsingReflectionInSingleClass() 和 FindState 的 moveToSuperclass()。从字面意思大概可以明白第一个方法就是关键所在，它是查找 SubscriberMethod 对象集合的核心代码，传入一个 FindState 对象，把查找过程中产生的数据保存。我们先看第二个方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToSuperclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 skipSuperClasses 那么循环走完</span></span><br><span class="line">    <span class="keyword">if</span> (skipSuperClasses) &#123;</span><br><span class="line">        clazz = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则获取其父类的 Class 对象</span></span><br><span class="line">        clazz = clazz.getSuperclass();</span><br><span class="line">        <span class="comment">// 如果父类是 java 或者 android 包下的，则循环走完</span></span><br><span class="line">        String clazzName = clazz.getName();</span><br><span class="line">        <span class="keyword">if</span> (clazzName.startsWith(<span class="string">"java."</span>) || clazzName.startsWith(<span class="string">"javax."</span>) || clazzName.startsWith(<span class="string">"android."</span>)) &#123;</span><br><span class="line">            clazz = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法逻辑很简单，有两种情况会终止循环，至于 skipSuperClasses 何时为 true 在后面分析。从这个方法还可以看出使用 EventBus 的时候，如果某个类没有进行注册操作，但其子类进行了注册操作，那么它依然可以使用实现订阅方法接收事件。</p>
<p>知道什么时候循环会完成了，我们回去看一看真正的核心方法 findUsingReflectionInSingleClass()，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 getDeclaredMethods() 获取订阅者 Class 对象本身的方法，不包含继承的方法，效率快</span></span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="comment">// 如果无法获取则使用 getMethods(0 获取订阅者 Class 对象的所有方法，包含其继承的所有方法，也就是所有父类的方法，效率低</span></span><br><span class="line">        methods = findState.clazz.getMethods();</span><br><span class="line">        <span class="comment">// 如果获取到了父类的方法，则不需要查找父类了，字段设为 true</span></span><br><span class="line">        findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">        <span class="comment">// 保证订阅方法的修饰符不能为 private、abstract、static，并且如果方法名是通过注解处理器生成的，则必须为 public</span></span><br><span class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="comment">// 保证订阅方法只有一个参数</span></span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 保证订阅方法必须使用 @Subscribe 注解</span></span><br><span class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// 检查这个方法能否被加入</span></span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        <span class="comment">// 找到一个订阅方法，则生成对应的 SubscriberMethod 对象，并保存入 FindState 中</span></span><br><span class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName + <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">            String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName + <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里逻辑处理较多，注释在代码里面，只有满足以下条件才会被当做订阅方法处理：</p>
<ul>
<li>方法必须带有 @Subscribe 注解</li>
<li>方法必须有且只有一个参数</li>
<li>方法的修饰符不能为 private、abstract、static，如果方法是通过注解处理器生成的，则必须是 public 的</li>
<li>方法不能被重复查找</li>
</ul>
<p>这里还有一个小逻辑，就是对于字段 strictMethodVerification 的判断，如果为 true，那么在不满足上述条件后，对应的带有 @Subscribe 注解的方法（普通方法当然不会报错）会提前抛出异常，如果开发过程中需要非常精确地定位错误，那么建议可以设置这个字段为 true。</p>
<p>逻辑中还有一个 FindState 的对象方法 checkAdd()用于检测是否重复，来看一看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;Class, Object&gt; anyMethodByEventType = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 某个类型的事件对应的方法</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;String, Class&gt; subscriberClassByMethodKey = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 方法签名对应的方法定义所在类</span></span><br><span class="line"><span class="keyword">final</span> StringBuilder methodKeyBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>); <span class="comment">// 作为方法签名的字符串缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将某个类型的事件对应的 Method 对象放入 Map 中，如果之前没有放入过任何对象，直接返回 true</span></span><br><span class="line">    Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">    <span class="keyword">if</span> (existing == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果之前存在 Method 对象，则去检查方法的签名</span></span><br><span class="line">        <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            anyMethodByEventType.put(eventType, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAddWithMethodSignature</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拼接方法签名，内容是（方法名 + &gt; + 事件的类型名称）</span></span><br><span class="line">    methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">    methodKeyBuilder.append(method.getName());</span><br><span class="line">    methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</span><br><span class="line">    String methodKey = methodKeyBuilder.toString();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将某个方法签名对应的定义该方法所在的类的 Class 对象放入 Map 中</span></span><br><span class="line">    Class&lt;?&gt; methodClass = method.getDeclaringClass(); </span><br><span class="line">    Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">    <span class="comment">// 如果之前没有放入过任何 Class 对象，或者之前的 Class 对象是现在 的 Class 对象的子类或者就是其本身，则表明可以被添加</span></span><br><span class="line">    <span class="keyword">if</span> (methodClassOld == <span class="keyword">null</span> || methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则这个方法不能被添加，并且还原之前的 Class 对象</span></span><br><span class="line">        subscriberClassByMethodKey.put(methodKey, methodClassOld);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的两个方法比较绕，具体有什么作用呢？其实是做了两层判断：第一层是判断同一类型的事件有多少个订阅方法，第二层是判断方法签名，具体作者的用意我也没太搞明白，但我理解了大概有两种情况：</p>
<ul>
<li>第一种情况：一个订阅者有多个订阅方法，方法名不同，但它们的参数类型（事件类型）都是相同的，那么遍历这些方法的时候，会多次调用到 checkAdd() 方法，由于 existing 不为 null，那么会进而调用 checkAddWithMethodSignature 方法，但是由于每个方法的名字都不同，因此 methodClassOld 会一直为 null，因此都会返回 true。也就是说，允许一个订阅者有多个参数类型（事件类型）相同的订阅方法。</li>
<li>第二种情况：继承的情况，每个订阅者都是有相同订阅方法，换句话说，继承者的订阅方法继承并重写，它们都有着一样的方法签名。方法的遍历会从继承者开始。在 checkAddWithMethodSignature 方法中，methodClassOld 为 null，那么继承者的订阅方法会被添加到列表中。接着，向上找到被继承者的订阅方法，由于 methodClassOld 不为 null 而且显然继承者不是被继承者的父类，methodClassOld.isAssignableFrom() 也会返回 false。也就是说，如果一个订阅者是继承并重写了订阅方法，那么只会允许添加继承者的订阅方法，被继承者的订阅方法会被忽略。</li>
</ul>
<h3 id="索引查找"><a href="#索引查找" class="headerlink" title="索引查找"></a>索引查找</h3><p>对于反射查找订阅方法的相关源码已经分析完了，接下来看看通过注解处理器生成的自定义索引类查找订阅方法的过程。我们回到 findSubscriberMethods() 方法，如果 ignoreGeneratedIndex 为 false 则会调用 findUsingInfo() 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 FindState 实例并初始化</span></span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里有一个循环，只要 FindState 的 clazz 对象不为 null，将会一直循环，其实这里就是把包括 clazz 本身及其所有父类都遍历了</span></span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 SubscriberInfo 接口对象，如果不为 null 则通过这个接口获取 SubscriberMethod 对象集合</span></span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则通过反射查找订阅方法l</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动至父类查找</span></span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回找到的 SubscriberMethod 集合并做了一些释放资源的操作</span></span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法和之前的 findUsingReflection() 方法的结构相似，只是循环的内容不一样，这部分内容就是通过一个索引类查找订阅方法（索引类通过注解处理器生成），要搞明白这部分内容，需要先了解几个新出现的接口和类：</p>
<ul>
<li>接口 SubscriberInfo：一个可以获取订阅方法相关信息的接口，有四个方法，分别是 getSubscriberClass()（获取订阅者的 Class 对象）、getSubscriberMethods()（获取 SubscriberMethod 对象集合）、getSuperSubscriberInfo()（获取订阅者父类的 SubscriberInfo 接口对象）、shouldCheckSuperclass()（获取是否应该检查父类的布尔值）</li>
<li>抽象类 AbstractSubscriberInfo：实现了 SubscriberInfo 接口，并且重写了其中 getSubscriberClass()、getSuperSubscriberInfo()、shouldCheckSuperclass() 方法</li>
<li>类 SimpleSubscriberInfo：继承自 AbstractSubscriberInfo，并且重写了 getSubscriberMethods() 方法</li>
<li>类 SubscriberMethodInfo：对于订阅方法封装的实体类，和之前的 SubscriberMethod 的区别是没有 Method 对象这个成员变量，它和 SubscriberMethod 之间是可以转换的</li>
<li>接口 SubscriberInfoIndex：可以获取 SubscriberInfo 接口对象，只有一个方法 getSubscriberInfo()</li>
<li>索引类 MyEventBusIndex：通过注解处理器自动生成的（如何生成文章开头已经提及），实现了 SubscriberInfoIndex 接口</li>
</ul>
<p>我们先来看看 getSubscriberInfo() 这个方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查此类不能是其父类</span></span><br><span class="line">    <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">        <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> superclassInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 subscriberInfoIndexes 这个参数是否为空，不为空则获取 SubscriberInfo 接口对象</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">            <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> info;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若没有获取到 SubscriberInfo 接口对象返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的作用是获取 SubscriberInfo 接口对象，并且做了两个判断，这里有个不明白的地方，根据代码跟踪发现 getSuperSubscriberInfo()  永远都是 null，所以主要是检查 subscriberInfoIndexes 这个参数是否为空，那这个参数是怎么来的呢？还记得文章开头提到的运行加速，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).build();</span><br></pre></td></tr></table></figure>
<p>如果加入了这行代码，会对这里的 subscriberInfoIndexes 参数进行赋值，类型是 SubscriberInfoIndex 接口，我们来看看这个索引类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里我在 MainActivity 里面定了一个 event() 方法，参数类型为 String</span></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(MainActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"event"</span>, String.class),</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类对于不同的使用方法会有所不同，可以看出它会记录订阅方法的相关信息，实现很简单，不再赘述。</p>
<p>对于索引查找订阅方法，有下面几个关系可以总结：</p>
<ul>
<li>SubscriberInfoIndex 接口可以获取 SubscriberInfo 接口对象</li>
<li>SubscriberInfo 接口可以获取 SubscriberMethod 对象（订阅方法对象）集合</li>
<li>MyEventBusIndex 类中有一个 Map，记录了订阅者的 SubscriberInfo 接口对象（实际上记录的是 SimpleSubscriberInfo，而 SimpleSubscriberInfo 继承于 AbstractSubscriberInfo，AbstractSubscriberInfo 实现了 SubscriberInfo 接口）</li>
</ul>
<p>从刚刚分析的代码可以看出如果不去设置运行加速的配置，那么 subscriberInfoIndexes 这个参数永远为 null，FindState 的成员变量 subscriberInfo 也会永远为 null，循环永远都是走 findUsingReflectionInSingleClass() 这个方法，也就是通过反射查找，这也解释了为什么叫加速，因为反射的性能远远不如普通代码。</p>
<p>如果设置了运行加速的配置，则会通过 SubscriberInfoIndex 接口获取 SubscriberInfo 的接口对象，然后通过 SubscriberInfo 获取 SubscriberMethod 对象集合，其中也进行了同反射查找相同的检查。</p>
<h2 id="订阅-1"><a href="#订阅-1" class="headerlink" title="订阅"></a>订阅</h2><p>到了这里寻找订阅方法就完成，接下来就是进行真正的订阅操作，回到之前的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SubscriberMethodFinder subscriberMethodFinder;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到指定订阅者的订阅方法，转换为 SubscriberMethod 对象集合</span></span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个 SubscriberMethod 对象进行订阅操作</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>订阅操作主要是调用了 subscribe() 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType; <span class="comment">// 事件类型对应的订阅方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; <span class="comment">// 订阅者对应的事件类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Key 是事件类型，Value 是 Subscription 对象集合，把它们装进 Map 中</span></span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果集合中已经存在这个订阅方法，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span> + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装入 Map 的操作，注意这里进行了排序处理，priority 值越高会排在前面，事件发布时也会优先</span></span><br><span class="line">    <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key 是订阅者的 Class 对象，Value 是事件类型的集合</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略一部分代码	</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只截取了一段代码，剩下的代码是处理粘性事件的，暂时不作讨论。这个方法主要用到了两个成员变量，subscriptionsByEventType 和 typesBySubscriber，在构造函数中对这两个参数进行了初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到订阅操作的方法，其主要作用就是对两个成员变量（subscriptionsByEventType 和 typesBySubscriber）进行赋值操作，需要注意的是，如果对于某个类型的事件的订阅方法已经订阅，再次订阅会产生错误，也就是同一个订阅者不能调用两次 register() 方法（当然是在没有取消订阅的情况下）。</p>
<p>这里还出现了一个新的类： Subscription，这是类是对于 SubscriberMethod 对象（订阅方法的实体类）的进一步封装，增加了两个属性，其中一个表明这个订阅方法属于哪一个订阅者，成员变量代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object subscriber; <span class="comment">// 订阅者</span></span><br><span class="line"><span class="keyword">final</span> SubscriberMethod subscriberMethod; <span class="comment">// 订阅方法</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> active; <span class="comment">// 是否是活动的</span></span><br></pre></td></tr></table></figure>
<h1 id="事件发布源码解析"><a href="#事件发布源码解析" class="headerlink" title="事件发布源码解析"></a>事件发布源码解析</h1><p>当订阅者订阅了一个事件后，任何角色都可以发送事件，如果发送的事件和订阅的事件类型一致，则订阅者可以接收到这个事件。接下来看看事件发送的源码，首先看看 post() 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 ThreadLocal 让不同线程拥有不同的 PostingThreadState 对象副本，线程之间互不影响</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取当前线程的 PostingThreadState 对象，并把要发送的事件加入队列</span></span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始事件的发布</span></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        <span class="comment">// 判断当前线程是否为主线程</span></span><br><span class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 循环发布事件队列中的事件</span></span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 状态重置</span></span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个新出现的类 PostingThreadState，这个类主要记录事件发布的状态，其字段如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;Object&gt;(); <span class="comment">// 要发布事件的对象集合，作为事件队列</span></span><br><span class="line"><span class="keyword">boolean</span> isPosting; <span class="comment">// 是否在发布中</span></span><br><span class="line"><span class="keyword">boolean</span> isMainThread; <span class="comment">// 发布事件所在的线程是否主线程</span></span><br><span class="line">Subscription subscription; <span class="comment">// 要接收事件的订阅方法</span></span><br><span class="line">Object event; <span class="comment">// 要发布的事件</span></span><br><span class="line"><span class="keyword">boolean</span> canceled; <span class="comment">// 是否取消事件发布</span></span><br></pre></td></tr></table></figure>
<p>回到 post() 方法，首先把 PostingThreadState 对象装进了 ThreadLocal，这是由于 post() 方法可以在任意线程并发调用，这样做可以有效隔离各线程事件发布的状态（其实内部机制就是对于不同的线程各自创建了一个新的 PostingThreadState 实例副本）。然后把事件放入了一个队列，通过循环发布每一个事件，调用了 postSingleEvent() 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> logNoSubscriberMessages; <span class="comment">// 是否打印未找到订阅方法的消息，默认为 true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sendNoSubscriberEvent; <span class="comment">// 是否发布 NoSubscriberEvent 事件，默认为 true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> eventInheritance; <span class="comment">// 发布事件是否具有继承性，默认为 true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布事件是否具有继承性</span></span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        <span class="comment">// 如果具有继承性，则找到该事件的所有父类事件，然后逐一发布</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有继承性，则只发布该事件本身</span></span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未找到对应事件的订阅方法，会根据 sendNoSubscriberEvent 发布一个 EventBus 定义的事件 NoSubscriberEvent</span></span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要是确认真正要发布的事件，判断了 eventInheritance 这个字段，默认为 true，从这里可以看出在使用的时候如果 eventInheritance（在构造 EventBus 实例时可以进行初始化，前面已经提及）设为 true，则会把发布事件的所有父类事件全部发布，例如：事件 A 继承于 B，那么发布一个 A 事件，订阅方法的事件类型为 A 和 B 都可以接收到这个事件。查找要发布的事件调用了以下的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 某个事件对应的所有父类事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">        <span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">            <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                eventTypes.add(clazz);</span><br><span class="line">                addInterfaces(eventTypes, clazz.getInterfaces());</span><br><span class="line">                clazz = clazz.getSuperclass();</span><br><span class="line">            &#125;</span><br><span class="line">            eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eventTypes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInterfaces</span><span class="params">(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; interfaceClass : interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!eventTypes.contains(interfaceClass)) &#123;</span><br><span class="line">            eventTypes.add(interfaceClass);</span><br><span class="line">            addInterfaces(eventTypes, interfaceClass.getInterfaces());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就是找其父类，不再详细分析。在确认了要发布的事件后，调用了 postSingleEventForEventType() 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType; <span class="comment">// 事件类型对应的订阅方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; <span class="comment">// 订阅者对应的事件类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据事件类型获取对应的 Subscription 对象集合（进行过订阅操作的订阅方法）  </span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行真正的事件发布动作，发布完成后则重置 PostingThreadState 对象的状态</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 对于每一个订阅方法都进行调用</span></span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码也较简单，用到了之前分析过的两个成员变量，直接看 postToSubscription() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandlerPoster mainThreadPoster; <span class="comment">// 用于在主线程中调用订阅方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BackgroundPoster backgroundPoster; <span class="comment">// 用于在子线程中调用订阅方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AsyncPoster asyncPoster; <span class="comment">// 用于在新的线程中调用订阅方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据订阅方法的线程模型来确定订阅方法调用的方式（线程模型的概念和使用前面已经提及）</span></span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            <span class="comment">// 不管发布事件处于什么线程，都在发布事件的线程调用订阅方法</span></span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="comment">// 如果发布事件的线程是主线程则直接调用订阅方法</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则会使用 mainThreadPoster 调用订阅方法</span></span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="comment">// 如果发布事件的线程是主线程则使用 backgroundPoster 调用订阅方法</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则直接调用订阅方法</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            <span class="comment">// 不管发布事件处于什么线程，都使用 asyncPoster 调用订阅方法</span></span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码可以说是 EventBus 的核心了，一个一个看，先看看在当前线程直接调用订阅方法的 invokeSubscriber() 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码很简单了，直接拿上对应订阅方法的 Method 对象进行反射调用，如果抛出 InvocationTargetException 错误则调用一个 handleSubscriberException() 方法来处理错误，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> throwSubscriberException; <span class="comment">// 是否抛出 EventBusException 异常，默认为 true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> logSubscriberExceptions; <span class="comment">// 是否打印调用方法失败的异常消息，默认为 true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sendSubscriberExceptionEvent; <span class="comment">// 是否发布 SubscriberExceptionEvent 事件，默认为 true</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleSubscriberException</span><span class="params">(Subscription subscription, Object event, Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果这个事件是由异常引起的则打印一些消息</span></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> SubscriberExceptionEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logSubscriberExceptions) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"SubscriberExceptionEvent subscriber "</span> + subscription.subscriber.getClass() + <span class="string">" threw an exception"</span>, cause);</span><br><span class="line">            SubscriberExceptionEvent exEvent = (SubscriberExceptionEvent) event;</span><br><span class="line">            Log.e(TAG, <span class="string">"Initial event "</span> + exEvent.causingEvent + <span class="string">" caused exception in "</span> + exEvent.causingSubscriber, exEvent.throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则根据各个字段进行相应的处理</span></span><br><span class="line">        <span class="keyword">if</span> (throwSubscriberException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Invoking subscriber failed"</span>, cause);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSubscriberExceptions) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Could not dispatch event: "</span> + event.getClass() + <span class="string">" to subscribing class "</span> + subscription.subscriber.getClass(), cause);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sendSubscriberExceptionEvent) &#123;</span><br><span class="line">            SubscriberExceptionEvent exEvent = <span class="keyword">new</span> SubscriberExceptionEvent(<span class="keyword">this</span>, cause, event, subscription.subscriber);</span><br><span class="line">            post(exEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的解释都在注释里了，很简单。在阅读各种线程模式下调用订阅方法的代码之前，要先看一看与之相关的两个类：PendingPost 和 PendingPostQueue。</p>
<p>首先是 PendingPost，我把它理解为一个即将发布的事件的实体类，里面包含了要发布的事件，对应的订阅方法，以及下一个 PendingPost 对象，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingPost</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span> ArrayList&lt;PendingPost&gt;(); <span class="comment">// 作为对象复用池</span></span><br><span class="line"></span><br><span class="line">    Object event; <span class="comment">// 要发布的事件</span></span><br><span class="line">    Subscription subscription; <span class="comment">// 发布事件对应的订阅方法</span></span><br><span class="line">    PendingPost next; <span class="comment">// 下一个 PendingPost 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PendingPost</span><span class="params">(Object event, Subscription subscription)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.event = event;</span><br><span class="line">        <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法用来获取一个 PendingPost 对象，会判断对象池里面是否有对象，如果有取出来进行初始化操作，否则新实例化一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> PendingPost <span class="title">obtainPendingPost</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = pendingPostPool.size();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                PendingPost pendingPost = pendingPostPool.remove(size - <span class="number">1</span>);</span><br><span class="line">                pendingPost.event = event;</span><br><span class="line">                pendingPost.subscription = subscription;</span><br><span class="line">                pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> pendingPost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PendingPost(event, subscription);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法是用来释放 PendingPost 对象的，当它用完后调用此方法，释放资源并将其放入对象池中，达到对象复用的目的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releasePendingPost</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">        pendingPost.event = <span class="keyword">null</span>;</span><br><span class="line">        pendingPost.subscription = <span class="keyword">null</span>;</span><br><span class="line">        pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加上同步锁避免并发问题，并且控制对象池的容量最大值是 10000</span></span><br><span class="line">        <span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pendingPostPool.size() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                pendingPostPool.add(pendingPost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，主要有两个方法，这两个方法应该对应出现，标志着一次事件的发布过程。接着来看一看 PendingPostQueue，这个类看名字就知道是 PendingPost 的队列实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingPostQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PendingPost head; <span class="comment">// 队列的头部</span></span><br><span class="line">    <span class="keyword">private</span> PendingPost tail; <span class="comment">// 队列的尾部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个 PendingPost 对象放入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新放入的 PendingPost 对象不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"null cannot be enqueued"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行队列头部和尾部的判断</span></span><br><span class="line">        <span class="keyword">if</span> (tail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail.next = pendingPost;</span><br><span class="line">            tail = pendingPost;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = tail = pendingPost;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Head present, but no tail"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒被 wait() 阻塞的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出队列中的一个 PendingPost 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> PendingPost <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = head;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tail = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pendingPost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待指定时间后取出队列中的一个 PendingPost 对象，或者在等待过程中如果调用了 enqueue()方法也会取出一个 PendingPost 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> PendingPost <span class="title">poll</span><span class="params">(<span class="keyword">int</span> maxMillisToWait)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            wait(maxMillisToWait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类主要是实现 PendingPost 队列的功能，提供入列和出列两个方法，出列有两个重载方法，一个是直接出列，另一个是可以在不清楚队列内是否为空的情况下使用。</p>
<p>分析完了 PendingPost 和 PendingPostQueue，我们回到 postToSubscription() 方法，根据不同的线程模式来调用订阅方法。之前分析过在当前线程直接调用订阅方法的情况，接着看看在 ThreadMode.MAIN 模式下的情况，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandlerPoster mainThreadPoster; <span class="comment">// 用于在主线程中调用订阅方法</span></span><br><span class="line"></span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>); <span class="comment">// 进行初始化操作</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="comment">// 如果发布事件的线程是主线程则直接调用订阅方法</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则会使用 mainThreadPoster 调用订阅方法</span></span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码都是与 ThreadMode.MAIN 模式下调用订阅方法相关的（其它的省略了），这里出现了一个新的类 HandlerPoster，它继承自 Handler 类，来看看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue; <span class="comment">// PendingPost 的队列实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage; <span class="comment">// 在 Handler 消息处理函数中的最大毫秒数，用以标记消息是否重发</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus; <span class="comment">// EventBus 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive; <span class="comment">// Handler 是否活跃，这个标志主要是控制在上一个消息没有处理结束前无法进行消息处理</span></span><br><span class="line"></span><br><span class="line">    HandlerPoster(EventBus eventBus, Looper looper, <span class="keyword">int</span> maxMillisInsideHandleMessage) &#123;</span><br><span class="line">        <span class="comment">// 这里指定消息回调方法 handleMessage() 的回调线程</span></span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        <span class="keyword">this</span>.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;</span><br><span class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用订阅方法的流程开始执行</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个 PendingPost 对象</span></span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 将 PendingPost 放入队列中</span></span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">                handlerActive = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 使用 Handler 发送一个空消息，在回调方法 handleMessage() 中处理逻辑，如果发送失败，抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 从队列中取出一个 PendingPost 对象，如果为 null，则直接返回终止循环，不会进行接下来操作</span></span><br><span class="line">                PendingPost pendingPost = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            handlerActive = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用 EventBus 的 invokeSubscriber() 方法，这个稍后再看</span></span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断方法调用是否超时，如果超时则重发一个消息，并且终止循环</span></span><br><span class="line">                <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">                <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rescheduled = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果进行了消息重发，则表明处理仍在进行中，不可进行下一个消息的处理</span></span><br><span class="line">            handlerActive = rescheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个要注意的地方，整个方法调用是一个循环，如果没有达到终止循环的条件（队列中已经没有 PendingPost 对象或者方法调用超时）则会取出下一个 PendingPost 对象继续进行方法的调用，直到取完为止。这里可以看出如果快速连续发布相同的事件，则订阅方法是按照顺序接收事件的，不会出现同时接收或者丢失的情况。</p>
<p>这个类主要使用了 Handler 的特性，调用方法所在的线程关键在于构造器中的 Looper 参数，从之前的代码可以看出使用了 Looper.getMainLooper()，那么不管当前线程情况如何，回调总会发生在主线程中，然后调用了 EventBus 的方法，来看看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">    Object event = pendingPost.event;</span><br><span class="line">    Subscription subscription = pendingPost.subscription;</span><br><span class="line">    <span class="comment">// 取出需要的参数后进行资源释放</span></span><br><span class="line">    PendingPost.releasePendingPost(pendingPost);</span><br><span class="line">    <span class="keyword">if</span> (subscription.active) &#123;</span><br><span class="line">        invokeSubscriber(subscription, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里代码很简单，其实就是获取 PendingPost 中保存的参数，然后调用 invokeSubscriber() 方法在当前线程调用订阅方法。到这里，如何在 ThreadMode.MAIN 模式下调用订阅方法就分析完了。至于如何在 Thread.BACKGROUND 模式和 Thread.ASYNC 模式下调用订阅方法就不作分析了，因为大部分原理和内容都相似，只不过是使用 Runnable 和 ExecutorService 进行线程的切换。</p>
<h1 id="取消订阅源码解析"><a href="#取消订阅源码解析" class="headerlink" title="取消订阅源码解析"></a>取消订阅源码解析</h1><p>如果一个订阅者不想再接收任何事件了，可以取消订阅，其方法 unregister() 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; <span class="comment">// 订阅者对应的事件类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取订阅者对应的事件类型</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历事件，把事件类型对应的该订阅者的订阅方法删除</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除这个订阅者的所有事件</span></span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，直接看 unsubscribeByEventType() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType; <span class="comment">// 事件类型对应的订阅方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取事件类型对应的订阅方法</span></span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定订阅者的订阅方法</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Subscription subscription = subscriptions.get(i);</span><br><span class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                <span class="comment">// 这里指定设为 false，是防止并发操作正在调用订阅方法，而取消订阅操作又没有完成</span></span><br><span class="line">                subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法其实就是把两个 Map 中和要取消订阅的订阅者相关的信息移除，很容易理解。到了这里，EventBus 的一般操作的源码已经全部分析完毕。</p>
<h1 id="关于粘性事件"><a href="#关于粘性事件" class="headerlink" title="关于粘性事件"></a>关于粘性事件</h1><p>粘性事件的使用方法文章开头已经提及，由于本文篇幅已经很长了，不再作出详细分析，其原理其实很简单。首先在订阅过程中，会读取一个名为 stickyEvents 的 Map，如果 Map 中有对象并且当前订阅方法的 sticky 属性为 true，则经过一系列检查（主要是检查这个粘性事件是否已经被订阅者接收过）根据情况进行事件发布。而如果发布时使用粘性事件发布，则会先把事件加入 stickyEvents 中，再进行普通事件的发布。</p>
<p>对于粘性事件，其订阅方法和事件发布会有以下几个逻辑关系：</p>
<ul>
<li>如果使用 post() 方法发布事件，则订阅者必须在之前先进行订阅操作才可以接收事件，订阅方法的 sticky 属性是否为 true 不影响</li>
<li>如果使用 postSticky() 方法发布事件，订阅者在之前进行过订阅操作，则都可以接收事件，订阅方法的 sticky 属性是否为 true 不影响</li>
<li>如果使用 postSticky() 方法发布事件，订阅者在之前没有进行过订阅操作，此时订阅方法的 sticky 属性起到作用，设为 true，当订阅者之后任意时刻进行订阅操作时都可以接收事件，而设为 false，此后订阅者再进行订阅操作也无法接收事件</li>
</ul>
<h1 id="关于注解处理器"><a href="#关于注解处理器" class="headerlink" title="关于注解处理器"></a>关于注解处理器</h1><p>EventBus 可以通过配置进行加速，其原理是通过注解处理器在编译期间生成了一个索引类，这样查找订阅方法阶段不需要使用发射，运行效率大大提高。注解处理器本文不作介绍，其用途也很广泛，可以参考我的另一篇博客：<a href="http://jinchim.com/2017/08/23/JBind/" target="_blank" rel="noopener">编写一个 Android 编译时注解框架的一般套路——以 ButterKnife 为例</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>EventBus 是一款非常值得学习的开源框架，其优秀的代码架构和穿插代码间的设计模式都是可以学习的技巧，代码中大量地方用到了对象复用池这个概念，可以减少实例化对象的次数，提高了运行效率。代码中还对并发操作会出现的各种情况都作了相应处理，比如使用 ThreadLocal 类保证単例模式下对象的成员变量能在不同的线程中各自使用，互不影响，这类处理还有很多。</p>
<p>文章很长，从开始读源码到写完博客花了两个星期时间，不过在过程确实学到了不少，这也是对自己学习过程中的一个记录。道路尚远，且行且珍惜！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/23/JBind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="金梧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="金梧的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/23/JBind/" itemprop="url">编写一个 Android 编译时注解框架的一般套路——以 ButterKnife 为例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-23T00:00:00+08:00">
                2017-08-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/23/JBind/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/08/23/JBind/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/08/23/JBind/" class="leancloud_visitors" data-flag-title="编写一个 Android 编译时注解框架的一般套路——以 ButterKnife 为例">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于熟悉 Android 应用开发的同学来说，肯定对 <a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">ButterKnife</a> 这个框架不陌生，这是一个专注于 Android 开发的 View 注入框架，可以减少大量的 findViewById() 以及 setOnClickListener() 代码，可视化一键生成，可以大大提高开发效率并且使得代码变得简洁。</p>
<p>本人通过学习其源码（源码地址：<a href="https://github.com/JakeWharton/butterknife/" target="_blank" rel="noopener">https://github.com/JakeWharton/butterknife/</a>）发现其核心思想是使用注解处理器技术来实现的，并不影响程序执行的效率，于是自己也撸了一个编译时注解框架，这种框架是在程序编译时生成一些开发过程中的重复代码来提高开发效率，所以开发这类框架的大体流程是相似的，下面来一一介绍。</p>
<h1 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h1><p>注解（一种用来描述 Java 元素的元数据，这里不作介绍）的生命周期分为 SOURCE（源文件保留）、CLASS（字节码文件保留）、RUNTIME（运行时保留），这里不讨论那些在运行时通过反射机制运行处理的注解，而是讨论在编译阶段处理的注解，Javac（编译 Java 源代码的程序）给我们提供了一个注解处理器，用来在编译时扫描和处理注解。</p>
<h2 id="AbstractProcessor"><a href="#AbstractProcessor" class="headerlink" title="AbstractProcessor"></a>AbstractProcessor</h2><p>每个注解处理器都是继承于 AbstractProcessor，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span></span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>init(ProcessingEnvironment env)：每一个注解处理器类都必须有一个空的构造函数。然而，这里有一个特殊的 init() 方法，它会被注解处理工具调用，并输入 ProcessingEnviroment 参数。ProcessingEnviroment 提供很多有用的工具类 Elements、Types 和 Filer。</li>
<li>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)：这相当于每个处理器的主函数 main()。你在这里写你的扫描、评估和处理注解的代码，以及生成 Java 文件。输入参数 RoundEnviroment，可以让你查询出包含特定注解的被注解元素。</li>
<li>getSupportedAnnotationTypes()：这里你必须指定，这个注解处理器是注册给哪个注解的。注意，它的返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。换句话说，你在这里定义你的注解处理器注册到哪些注解上。</li>
<li>getSupportedSourceVersion()：用来指定你使用的 Java 版本。通常这里返回 SourceVersion.latestSupported()，也可以直接指定具体的版本，比如 SourceVersion.RELEASE_7。</li>
</ul>
<h2 id="注册注解处理器"><a href="#注册注解处理器" class="headerlink" title="注册注解处理器"></a>注册注解处理器</h2><p>如何让 Javac 在编译时运行我们自定义的处理器呢？需要在最后打包的 .jar 文件中的 /META-INF/services/ 下放入一个文件，文件名为 javax.annotation.processing.Processor，内容就是刚刚定义的处理器的全名列表，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.example.MyProcess</span><br></pre></td></tr></table></figure>
<p>这样在编译 .jar 文件时便会执行指定的处理器的代码。</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>介绍了注解处理器的基本用法后，我们的框架之路可以开始了！先看看 ButterKnife 的基本用法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindView</span>(R.id.title) TextView title;</span><br><span class="line">    <span class="meta">@BindView</span>(R.id.subtitle) TextView subtitle;</span><br><span class="line">    <span class="meta">@BindView</span>(R.id.footer) TextView footer;</span><br><span class="line">    Unbinder unbider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.simple_activity);</span><br><span class="line">        unbider = ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unbider.unbid();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到仅仅用了一个注解就可以实现对控件的绑定，再也不需要大量重复的控件查找方法了，这里我们实现的框架只针对一个控件绑定，并且只针对 Activity 下的控件绑定，其他比如资源绑定、点击事件等不去实现，因为其原理是一样的。根据 ButterKnife 的用法，我们的框架需要制定一些规则如下：</p>
<ul>
<li>注解只能作用于成员变量上，并且成员变量的类型必须是 View 或者其子孙类。</li>
<li>注解所在的类必须是 Activity 或者其子孙类</li>
<li>注解的元素不能有 final、static、private 修饰符</li>
</ul>
<p>对于前两点很好理解，至于第三点，之后在生成代码后便会明白。</p>
<h1 id="模块定义与实现"><a href="#模块定义与实现" class="headerlink" title="模块定义与实现"></a>模块定义与实现</h1><p>针对上面的需求分析，我们需要建立多个模块，定义如下：</p>
<ul>
<li>annotations：用于存放所有的注解，Java 模块</li>
<li>compiler：用于编写注解处理器，Java 模块</li>
<li>api：给开发者提供使用的 api，Android 模块</li>
<li>app：测试模块， Android 模块</li>
</ul>
<p>其依赖关系是：complier 依赖 annotations，api 依赖 annotations，app 依赖 api。</p>
<h2 id="annotations-模块"><a href="#annotations-模块" class="headerlink" title="annotations 模块"></a>annotations 模块</h2><p>对于 annotations 模块非常简单，这里我们只需要定义一个注解，之前制定的规则是注解只能作用于成员变量上，在这里体现了，只需要将注解的修饰对象范围指定为 ElementType.FIELD 即可，所以我们这样定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JBind &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="compiler-模块"><a href="#compiler-模块" class="headerlink" title="compiler 模块"></a>compiler 模块</h2><p>这个模块的功能主要是对代码中的注解进行扫描、处理并生成对应的代码，在进行编码前，我们需要对 Java 文件的结构有所了解。Java 文件是由 Element（元素）构成的，它分为以下几种：</p>
<ul>
<li>VariableElement 一般代表成员变量</li>
<li>ExecutableElement 一般代表类中的方法</li>
<li>TypeElement 一般代表代表类</li>
<li>PackageElement 一般代表包</li>
</ul>
<p>所以在扫描注解时，返回的其实就是一个 Element，里面包含我们需要的所有信息（直接或间接）。</p>
<h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><p>我们编写一个类，继承于 AbstractProcessor，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JBindProcess</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 里面包含一些方法获取有用的信息</span></span><br><span class="line">    <span class="keyword">private</span> Elements elements;</span><br><span class="line">    <span class="comment">// 用来生成文件的工具</span></span><br><span class="line">    <span class="keyword">private</span> Filer filer;</span><br><span class="line">    <span class="comment">// 日志辅助工具，在这个处理器内部出错都要使用这个</span></span><br><span class="line">    <span class="keyword">private</span> Messager messager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnvironment);</span><br><span class="line">        elements = processingEnvironment.getElementUtils();</span><br><span class="line">        filer = processingEnvironment.getFiler();</span><br><span class="line">        messager = processingEnvironment.getMessager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; annotataionTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        annotataionTypes.add(JBind.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">return</span> annotataionTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.RELEASE_7;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取所有使用 JBind 注解的元素</span></span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(JBind.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释都在注释里了，这段代码基本可以看作是模板，编写此类框架都要这样写，后续的处理基本上都是在 process() 方法中了。</p>
<p>需要注意一个地方，之前说过注册注解器需要定义一个 javax.annotation.processing.Processor 文件，Google 官方给了一个插件可以自动生成这个文件，使用方式是在类名前加上注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JBindProcess</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span></span></span><br></pre></td></tr></table></figure>
<p>当然使用前需要引入一个包，在 build.gradle 中的 dependencies 标签中加入：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.google.auto.service:auto-service:1.0-rc3'</span></span><br></pre></td></tr></table></figure>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>对于扫描到的注解，我们应该要把它结构化，在一个类里面含有的所有注解信息应该是一个对象，每一个注解信息也应该是一个对象。首先定义一个代表单个注解信息的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一个注解信息需要提供三个方法：获取注解元素类型，获取注解元素名称、获取注解值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JBindField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> VariableElement variableElement;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> resId;</span><br><span class="line"></span><br><span class="line">    JBindField(VariableElement variableElement) &#123;</span><br><span class="line">        <span class="keyword">this</span>.variableElement = variableElement;</span><br><span class="line">        JBind bind = variableElement.getAnnotation(JBind.class);</span><br><span class="line">        resId = bind.value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getResId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getFiledName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> variableElement.getSimpleName().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TypeMirror <span class="title">getFiledType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> variableElement.asType();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，就不多解释了，下面再定义一个代表一个类里面所有注解信息的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JBindClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Elements elements;</span><br><span class="line">    <span class="keyword">private</span> TypeElement typeElement;</span><br><span class="line">    <span class="keyword">private</span> List&lt;JBindField&gt; jBindFields;</span><br><span class="line"></span><br><span class="line">    JBindClass(Elements elements, TypeElement typeElement) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elements = elements;</span><br><span class="line">        <span class="keyword">this</span>.typeElement = typeElement;</span><br><span class="line">        jBindFields = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addField</span><span class="params">(JBindField jBindField)</span> </span>&#123;</span><br><span class="line">        jBindFields.add(jBindField);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好注解类之后我们的任务就很简单了，就是把扫描到的所有注解转换成 JBindClass 对象，然后再根据 JBindClass 对象生成代码。当然在转换过程中不要忘了我们之前制定的规则，需要对注解信息进行判断，这里简单介绍一下之前提到过的 Messager 类。</p>
<p>Messager 是 Javac 在编译过程中用来打印日志的辅助工具，但它作用不止于此，就本人现在知道的，它可以中断编译。什么意思呢，Messager 信息分为几种：ERROR、WARNING、MANDATORY_WARNING、NOTE、OTHER，从字面意思就可以看出各自的含义，如果指定信息为 ERROR，那么在运行到这句代码时，不仅会在编译控制台打印消息，还会直接中断编译。仔细一想就明白了，我们平时编译程序如果有语法错误，Javac 便是通过这个工具来打印错误消息并且中断编译的。</p>
<p>在我们的 JBindProcess 中，只需要用到 ERROR 和 NOTE 这两个类型，我们便可以写出几个辅助方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(Element element, String message, Object... args)</span> </span>&#123;</span><br><span class="line">    printMessage(Diagnostic.Kind.ERROR, element, message, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">note</span><span class="params">(Element element, String message, Object... args)</span> </span>&#123;</span><br><span class="line">    printMessage(Diagnostic.Kind.NOTE, element, message, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(Diagnostic.Kind kind, Element element, String message, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        message = String.format(message, args);</span><br><span class="line">    &#125;</span><br><span class="line">    messager.printMessage(kind, message, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解了日志辅助工具后，我们可以开始进行注解信息到 JBindClass 的转换过程了，根据之前的规则，可以写一个公共的方法，用来判断给定元素的类型是不是某个类型及其子孙类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSubtypeOfType</span><span class="params">(TypeMirror typeMirror, String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (typeMirror == <span class="keyword">null</span> || type == <span class="keyword">null</span> || type.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type.equals(typeMirror.toString())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (typeMirror.getKind() != TypeKind.DECLARED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DeclaredType declaredType = (DeclaredType) typeMirror;</span><br><span class="line">    List&lt;? extends TypeMirror&gt; typeArguments = declaredType.getTypeArguments();</span><br><span class="line">    <span class="keyword">if</span> (typeArguments.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        StringBuilder typeString = <span class="keyword">new</span> StringBuilder(declaredType.asElement().toString());</span><br><span class="line">        typeString.append(<span class="string">'&lt;'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; typeArguments.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                typeString.append(<span class="string">','</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            typeString.append(<span class="string">'?'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        typeString.append(<span class="string">'&gt;'</span>);</span><br><span class="line">        <span class="keyword">if</span> (typeString.toString().equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Element element = declaredType.asElement();</span><br><span class="line">    <span class="keyword">if</span> (!(element <span class="keyword">instanceof</span> TypeElement)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TypeElement typeElement = (TypeElement) element;</span><br><span class="line">    TypeMirror superType = typeElement.getSuperclass();</span><br><span class="line">    <span class="keyword">if</span> (isSubtypeOfType(superType, type)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (TypeMirror interfaceType : typeElement.getInterfaces()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSubtypeOfType(interfaceType, type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要稍微解释下 TypeMirror。Element 代表的是源代码，TypeElement 代表的是源代码中的类型元素，例如类。然而，TypeElement 并不包含类本身的信息。我们可以从 TypeElement 中获取类的名字，但是获取不到类的信息，例如它的父类。这种信息需要通过 TypeMirror 获取。我们可以通过调用 Element 对象的 asType() 获取元素的 TypeMirror。有了这个方法，我们便开始再 process() 方法里面写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录扫描到的指定的注解信息</span></span><br><span class="line">    Map&lt;TypeElement, JBindClass&gt; jBindClassMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取所有使用 JBind 注解的元素</span></span><br><span class="line">    Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(JBind.class);</span><br><span class="line">    <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">        <span class="comment">// 检查是否为 VariableElement</span></span><br><span class="line">        <span class="keyword">if</span> (!(element <span class="keyword">instanceof</span> VariableElement)) &#123;</span><br><span class="line">            error(element, <span class="string">"%s is not a variable element."</span> + element.getSimpleName());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 TypeElement</span></span><br><span class="line">        TypeElement typeElement = (TypeElement) element.getEnclosingElement();</span><br><span class="line">        <span class="comment">// 获取 VariableElement</span></span><br><span class="line">        VariableElement variableElement = (VariableElement) element;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断注解的变量修饰符有没有 private、final 以及 static</span></span><br><span class="line">        <span class="keyword">for</span> (Modifier modifier:variableElement.getModifiers()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (modifier == Modifier.FINAL || modifier == Modifier.PRIVATE || modifier == Modifier.STATIC) &#123;</span><br><span class="line">                error(element, <span class="string">"@Bind fields (%s) must not be private, final or static."</span>, typeElement.asType().toString() + <span class="string">"."</span> + variableElement.getSimpleName());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断注解的变量类型是不是 View 及其子孙类</span></span><br><span class="line">        <span class="keyword">if</span> (!isSubtypeOfType(element.asType(), Type_View)) &#123;</span><br><span class="line">            error(element, <span class="string">"@Bind fields must extend from View, is not extends from %s."</span>, element.asType().toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断注解所属的类是不是 Activity 及其子孙类</span></span><br><span class="line">        <span class="keyword">if</span> (!isSubtypeOfType(typeElement.asType(), Type_Activity)) &#123;</span><br><span class="line">            error(element, <span class="string">"@Bind fields must in class of extends from Activity, not in class of extends from %s."</span>, typeElement.asType().toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注解信息初始化</span></span><br><span class="line">        JBindClass jBindClass = jBindClassMap.get(typeElement);</span><br><span class="line">        <span class="keyword">if</span> (jBindClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jBindClass = <span class="keyword">new</span> JBindClass(<span class="keyword">this</span>.elements, typeElement);</span><br><span class="line">            jBindClassMap.put(typeElement, jBindClass);</span><br><span class="line">        &#125;</span><br><span class="line">        jBindClass.addField(<span class="keyword">new</span> JBindField(variableElement));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码就蛮简单了，仅仅是作了些简单的判断，并且把最后的注解信息放到了一个 Map 中存储，方便后面进行代码生成。值得一提的是这个方法的返回值，若返回 false，表示本轮注解未声明并且可能要求后续其它的 Processor 处理它们；若返回 true，则代表这些注解已经声明并且不要求后续 Processor 来处理它们。所以当发生错误后，调用 error() 方法打印消息并中断编译，返回 true 不再进行其他处理器的处理。</p>
<h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>我们回过头去想一想我们需要生成什么样的代码。肯定是要一个单独的类用来盛放像 findViewById() 这样的方法，最简单的做法就是针对每一个 Activity 都有一个对应的类来管理这些代码，而这些代码方法构造器中，使用时进行反射处理便可以进行调用，有了这个想法，我们应该想生成这样的代码（假设在 MainActivity 中定义了一个 textView 的 TextView）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有这个注解是因为 Android 在编译时会检查 findViewById() 的参数是否为 @ResId 类型，这里忽略了检查，否则编译不通过</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ResourceType"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_JBind</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MainActivity activity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_JBind</span><span class="params">(MainActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(activity, activity.getWindow().getDecorView());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有两个构造方法是为了扩展考虑，这里一个构造器也行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_JBind</span><span class="params">(MainActivity activity, View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">        activity.textView = (TextView) view.findViewById(xxx);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码可以解释之前我们制定的规则的第三点：注解的元素不能有 final、static、private 修饰符，如果有，便不满足 Java 语言的规则。</p>
<p>这里其实还有一个问题，就是对象释放的问题，毕竟不是在 Activity 中操作的，如果不释放 activity 的引用有可能造成内存泄露，所以还需要一个 unbind() 方法，那是不是直接加一个 unbind() 方法呢？这个当然可以，本人一开始也是这样做的，但是在读了大神的源码后豁然开朗，使用动态代理，先定义一个接口，里面有一个 unbind() 方法，生成的类实现这个接口，再去实现具体的方法。这样做的好处在于，在外部调用生成类构造器绑定控件时可以返回这个接口，需要释放引用时调用接口即可，不用再次反射生成类来调用它本身的 unbind() 方法，这样提高了出现运行效率。不得不说大神的思维就是 666 啊！接口可以这样定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Unbinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Unbinder Empty = <span class="keyword">new</span> Unbinder() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口可以放到 api 模块中去，更加符合模块化的思想。这里定义了一个 Empty 实现了空方法，是为了在反射出错时不至于给一个空的 Unbinder 对象发生空指针，这一招也是学大神的。</p>
<p>接口定义好了，我们修改下生成类的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ResourceType"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_JBind</span> <span class="keyword">implements</span> <span class="title">Unbinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MainActivity activity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_JBind</span><span class="params">(MainActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(activity, activity.getWindow().getDecorView());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_JBind</span><span class="params">(MainActivity activity, View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">        activity.textView = (TextView) view.findViewById(xxx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        activity.textView = <span class="keyword">null</span>;</span><br><span class="line">        activity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在生成代码前我们需要了解下 javapoet 这个东西，这是一个用于代码生成的工具，比起自己用字符串去拼接，这个简直不能再好了！推荐一篇帖子了解 javapoet 的使用——<a href="http://www.jianshu.com/p/95f12f72f69a" target="_blank" rel="noopener">javapoet，让你从重复无聊的代码中解放出来</a>。</p>
<p>熟悉了 javapoet 后我们在 JBindClass 写一个方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使用 ClassName 的 get() 方法拿到指定具体路径的类名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClassName Unbinder = ClassName.get(<span class="string">"com.jinchim.api"</span>, <span class="string">"Unbinder"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClassName View = ClassName.get(<span class="string">"android.view"</span>, <span class="string">"View"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">JavaFile <span class="title">prepareFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加构造器</span></span><br><span class="line">    MethodSpec.Builder constructor1 = MethodSpec</span><br><span class="line">        .constructorBuilder()</span><br><span class="line">        .addModifiers(Modifier.PUBLIC)</span><br><span class="line">        .addParameter(TypeName.get(typeElement.asType()), <span class="string">"activity"</span>)</span><br><span class="line">        .addStatement(<span class="string">"this(activity, activity.getWindow().getDecorView())"</span>);</span><br><span class="line">    MethodSpec.Builder constructor2 = MethodSpec</span><br><span class="line">        .constructorBuilder()</span><br><span class="line">        .addModifiers(Modifier.PUBLIC)</span><br><span class="line">        <span class="comment">// 这里是添加方法参数，需要指定参数类型和参数变量</span></span><br><span class="line">        <span class="comment">// 先使用 TypeElement 的 asType() 方法拿到 TypeMirror，再使用 TypeName 的 get() 方法拿到当前注解信息所属的类名称（当前类名当然是注解所在的类）</span></span><br><span class="line">        .addParameter(TypeName.get(typeElement.asType()), <span class="string">"activity"</span>)</span><br><span class="line">        .addParameter(View, <span class="string">"view"</span>)</span><br><span class="line">        <span class="comment">// 添加代码，进行为空的判断</span></span><br><span class="line">        .beginControlFlow(<span class="string">"if (activity == null)"</span>)</span><br><span class="line">        .addStatement(<span class="string">"return"</span>)</span><br><span class="line">        .endControlFlow()</span><br><span class="line">        <span class="comment">// 添加代码，进行成员变量赋值</span></span><br><span class="line">        .addStatement(<span class="string">"this.activity = activity"</span>);</span><br><span class="line">    <span class="keyword">for</span> (JBindField jBindField : jBindFields) &#123;</span><br><span class="line">        <span class="comment">// $N 用于指定另外一个通过名字生成的声明，&amp;T 用于指定类型，$L 用于指定字符串的连接（没有双引号），$S 用于指定字符串（有双引号）</span></span><br><span class="line">        constructor2.addStatement(<span class="string">"activity.$N = ($T) view.findViewById($L)"</span>, jBindField.getFiledName(), jBindField.getFiledType(), jBindField.getResId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加 unbind() 方法</span></span><br><span class="line">    MethodSpec.Builder unbind = MethodSpec</span><br><span class="line">        .methodBuilder(<span class="string">"unbind"</span>)</span><br><span class="line">        .addAnnotation(Override.class)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC)</span><br><span class="line">        .beginControlFlow(<span class="string">"if (activity == null)"</span>)</span><br><span class="line">        .addStatement(<span class="string">"return"</span>)</span><br><span class="line">        .endControlFlow();</span><br><span class="line">    <span class="keyword">for</span> (JBindField jBindField : jBindFields) &#123;</span><br><span class="line">        unbind.addStatement(<span class="string">"activity.$N = null"</span>, jBindField.getFiledName());</span><br><span class="line">    &#125;</span><br><span class="line">    unbind.addStatement(<span class="string">"activity = null"</span>);</span><br><span class="line">    <span class="comment">// 添加成员变量</span></span><br><span class="line">    FieldSpec.Builder field = FieldSpec.builder(TypeName.get(typeElement.asType()), <span class="string">"activity"</span>);</span><br><span class="line">    <span class="comment">// 添加类注解</span></span><br><span class="line">    AnnotationSpec.Builder suppressWarnings = AnnotationSpec</span><br><span class="line">        .builder(SuppressWarnings.class)</span><br><span class="line">        .addMember(<span class="string">"value"</span>, <span class="string">"\"ResourceType\""</span>);</span><br><span class="line">    <span class="comment">// 构建类对象</span></span><br><span class="line">    TypeSpec typeSpec = TypeSpec</span><br><span class="line">        .classBuilder(typeElement.getSimpleName() + <span class="string">"_JBind"</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC)</span><br><span class="line">        .addAnnotation(suppressWarnings.build())</span><br><span class="line">        .addSuperinterface(Unbinder)</span><br><span class="line">        .addField(field.build())</span><br><span class="line">        .addMethod(constructor1.build())</span><br><span class="line">        .addMethod(constructor2.build())</span><br><span class="line">        .addMethod(unbind.build())</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> JavaFile.builder(elements.getPackageOf(typeElement).getQualifiedName().toString(), typeSpec).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再在 process() 方法中加一些代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录扫描到的指定的注解信息</span></span><br><span class="line">    Map&lt;TypeElement, JBindClass&gt; jBindClassMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取所有使用 JBind 注解的元素</span></span><br><span class="line">    Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(JBind.class);</span><br><span class="line">    <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">        ... <span class="comment">// 表示之前的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成代码文件</span></span><br><span class="line">    <span class="keyword">for</span> (TypeElement typeElement : jBindClassMap.keySet()) &#123;</span><br><span class="line">        JBindClass jBindClass = jBindClassMap.get(typeElement);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jBindClass.prepareFile().writeTo(filer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            error(typeElement, <span class="string">"Generate file failed, reason: %s."</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，compiler 模块就完成了，此时如果在 app 模块写有 @JBind 注解，编译后便会生成我们想要的代码，下面来实现给开发者调用的 api 模块应该怎样设计。</p>
<h2 id="api-模块"><a href="#api-模块" class="headerlink" title="api 模块"></a>api 模块</h2><p>对于生成好的代码，它有一个特点，里面只有两个构造方法和一个 unbind() 方法，而且他的路径就在注解所在 Activity 的那个包下面，名称就是 (Activity)_JBind。有了这个特点，我们写一个这样的类即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JBindSDK</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = JBindSDK.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        String className = activity.getPackageName() + <span class="string">"."</span> + activity.getLocalClassName() + <span class="string">"_JBind"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(className);</span><br><span class="line">            Constructor&lt;? extends Unbinder&gt; constructor = map.get(clazz);</span><br><span class="line">            <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                constructor = clazz.getConstructor(activity.getClass());</span><br><span class="line">                map.put(clazz, constructor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance(activity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Unbinder.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先利用反射获取生成类的类对象，然后获取其构造器对象调用之，返回一个 Unbinder 对象，如果发生异常便返回一个空的 Unbinder 对象，不至于外部调用时发生空指针异常。 </p>
<p>这里还有一个小技巧，就是把生成类的构造器对象缓存了起来，提高了程序的执行效率。</p>
<p>至此，框架开发基本完成，使用方式和 ButterKnife 基本相同（文章开头提到过）。</p>
<p>项目的 github 地址：<a href="https://github.com/jinchim/JBind-Android/" target="_blank" rel="noopener">https://github.com/jinchim/JBind-Android/</a></p>
<h1 id="如何引用框架"><a href="#如何引用框架" class="headerlink" title="如何引用框架"></a>如何引用框架</h1><p>对于 ButterKnife，有一个非常优雅的引入方式：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.jakewharton:butterknife:8.8.1'</span></span><br><span class="line">annotationProcessor <span class="string">'com.jakewharton:butterknife-compiler:8.8.1'</span></span><br></pre></td></tr></table></figure>
<p>这是 gradle 提供的优雅地引入外部开发包的方式，需要把项目编译打包并且上传至 jcenter，至于如何把项目上传至 jcenter，推荐一篇大神的博客：<a href="http://blog.csdn.net/lmj623565791/article/details/51148825/" target="_blank" rel="noopener">Android 快速发布开源项目到 jcenter</a>。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>写博客并不只是记录自己的学习过程，因为在写博客的过程中，也会更加理解所写的内容，虽然比较花时间，但这是一个很好的总结过程，也希望自己能一直坚持下去。坚信一句话，量变引起质变！</p>
<p>参考文章：</p>
<ul>
<li><a href="https://race604.com/annotation-processing/" target="_blank" rel="noopener">Java注解处理器</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/51931859/" target="_blank" rel="noopener">Android 如何编写基于编译时注解的项目</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/26/opencv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="金梧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="金梧的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/opencv/" itemprop="url">初探 OpenCV 3.2 物体识别：级联分类器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-26T00:00:00+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/26/opencv/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/06/26/opencv/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/06/26/opencv/" class="leancloud_visitors" data-flag-title="初探 OpenCV 3.2 物体识别：级联分类器">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这段时间心情不是很美丽。一是觉得在现在这个公司已经提升不了什么能力了，而且想跳个大公司一直吃闭门羹；二来突然思考自己是否能一直在这个行业干下去，顿时有点刚毕业时的迷茫了，这也可能是一月一次的“大姨父”。经过一段时间的思考，觉得还是应该稳扎稳打坚持下去，毕竟哥们儿现在除了这个也没其他技能了（手动流泪~~~）。于是在一个月黑风高的夜晚，突然想起来在大学时期参加过的一个软件比赛，那时候是真开心啊，毕竟仗着那个比赛在系里横着走，而且当时交了第一个喜欢的女朋友，简直让人膨胀……</p>
<p>扯远了，当时比赛我们弄了一个基于摄像头识别的软件，初衷是因为我爱看哈利波特，希望能通过摄像头实现用手势变魔法的功能，于是用到了 OpenCV。当时的底层算法是我的另一个队友写的，所以我对 OpenCV 基本不懂，现在突发奇想把 OpenCV 从头到尾学了一遍，这里主要把基于 OpenCV 级联分类器如何识别目标物体的过程记录下来，希望能给需要的人一点帮助。</p>
<h1 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h1><p>OpenCV 是一个跨平台的计算机视觉库，它实现了图像处理和计算机视觉方面的很多通用算法，是一个非常强大的开源库。</p>
<p>具体应该怎么实现物体的识别呢？我们应该知道，在计算机上看到的图像都是由一颗颗的像素点组成的，而每颗像素点的基本属性就是其颜色值，经过标准的定义，就可以用一个计算机数据结构的数据来表示一副图像。这样的标准有很多，我们经常听到的 RGB 三通道（红、绿、蓝三原色可以组成任意颜色）就是最常用的标准。OpenCV 研究的就是如何利用各种算法对像素点进行转换，达到不同的效果，而物体识别需要的过程比较繁琐，概括起来就是：</p>
<ul>
<li>取样本，包括正样本（包含需要识别物体的图片）和负样本（不包含正样本的图片）。</li>
<li>对正样本进行预处理，包括图片降燥、灰度化、直方图均衡化、边缘检测、轮廓提取等。</li>
<li>提取正样本中比较明显的特征，量化为计算机数据。</li>
<li>使用机器学习算法学习样本数据，使应用程序具有对数据分类（两类或多类）的能力，这一过程称为机器训练。</li>
<li>使用训练好的模型对目标物体进行检测。</li>
</ul>
<p>这是一般进行物体识别的步骤，其中提取样本特征这一步比较困难，因为要自己找到明显的特征需要较高深的算法，这不是像我这种入门菜鸟所能做到的。没关系，OpenCV 提供了级联分类器这个强大的东东，使用它只需要把图片缩小到足够小直接作为特征训练分类器。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="下载开发工具包"><a href="#下载开发工具包" class="headerlink" title="下载开发工具包"></a>下载开发工具包</h2><p>首先去 <a href="http://opencv.org/releases.html" target="_blank" rel="noopener">OpenCV</a> 的官网下载 Windows 平台的开发包，这里主要是需要使用它的两个应用程序。本人还下载了对应的 Android 平台的开发包，因为我最终要在 Android 上执行。</p>
<h2 id="准备正样本"><a href="#准备正样本" class="headerlink" title="准备正样本"></a>准备正样本</h2><p>对于刚性物体，比如汽车 logo，只需要一张正面的亮度足够的图片即可，因为 OpenCV 的算法可以对一张图片进行各种旋转操作，从而产生大量的样本；而非刚性物体，比如人脸，需要自行准备大量的图片，数量越多越好，至少有 1000 张图片。这里我就准备了两张 logo 图片，因为我最后只需要识别两个 logo 即可，如图：</p>
<img src="/2017/06/26/opencv/img01.png">
<p><br></p>
<blockquote>
<p>非刚性物体的正样本图片应该是经过处理的、尺寸统一的小图片，大小控制在 20 * 20 左右，尽量让目标物体充满图片，也就是背景越少越好，而且背景色要统一。</p>
</blockquote>
<h2 id="准备负样本"><a href="#准备负样本" class="headerlink" title="准备负样本"></a>准备负样本</h2><p>负样本需要在机器训练中使用，其数量是越多越好，可以是任意的图片，只要不包含目标物体即可，这里我准备了将近 500M 的图片，真正使用时还是发现少了，建议一般至少准备 2G 的图片，可以从网上下载各种素材包，或者从一段视频中截取图片。下图是我准备的一部分负样本图片：</p>
<img src="/2017/06/26/opencv/img02.png">
<p><br></p>
<blockquote>
<p>负样本图片的尺寸可以无限大，但是一定不能小于正样本图片的尺寸。</p>
</blockquote>
<h2 id="找到自带的程序"><a href="#找到自带的程序" class="headerlink" title="找到自带的程序"></a>找到自带的程序</h2><p>准备样本是一个繁琐且漫长的过程，如果想要分类器取得好的效果，样本数量一定要尽量多。样本准备就绪之后，就可以开始训练了。</p>
<p>找到之前下载好的开发工具包，在 /opencv/build/x64/vc14/bin/ 目录下，有一些程序可供我们进行机器训练，如下图：</p>
<img src="/2017/06/26/opencv/img03.png">
<p><br>我们需要其中的 opencv_createsamples.exe 和 opencv_traincascade.exe 两个程序，前者是用来创建正样本描述文件的，后者是用来进行机器训练的，当然，记得把需要的 dll 文件拷贝。</p>
<h1 id="创建样本描述文件"><a href="#创建样本描述文件" class="headerlink" title="创建样本描述文件"></a>创建样本描述文件</h1><h2 id="正样本描述文件"><a href="#正样本描述文件" class="headerlink" title="正样本描述文件"></a>正样本描述文件</h2><p>对于正样本，需要一个后缀为 .vec 的描述文件，OpenCV 提供了一个程序 opencv_createsamples 用来生成描述文件，我们先来看看这个程序怎么使用。打开 cmd，目录切换到 /opencv/build/x64/vc14/bin/，输入 opencv_createsamples.exe，可以看到如下选项：</p>
<img src="/2017/06/26/opencv/img04.jpg">
<ul>
<li>-info：指定正样本的信息文件，后缀可以是 .txt、.dat，这个文件列出了所有正样本图片的文件名、包含待检物的数量和待检物的范围参数。比如：samples_1.jpg 1 0 0 20 20 这样，就是指某个正样本是 samples_1.jpg 的图片，图片中有 1个目标区域，区域的左上角坐标为 (0,0)，区域的宽度为 20 像素，长度为 20 像素。注意样本图片和这里的参数相符，每一张图片的信息占一行，不能有空行。</li>
<li>-img：指定正样本的图片文件，对于只有一张图片样本的刚性物体，应该使用这个选项来产生大量样本，通过一张图片的扭曲形变成多张图片作为样本，注意这个选项和 -info 选项只有一个能生效。</li>
<li>-vec：指定生成样本描述文件的路径和文件名。</li>
<li>-bg：样本背景文件，后缀可以是 .txt、.dat，如果省略，则使用 bgcolor 的值填充作为背景，内容就是图片名，每一张图片的信息占一行，不能有空行。</li>
<li>-num：要创建的正样本的数量，使用 -info 生成时，不要比你准备的正样本图片数量大就行了。</li>
<li>-bgcolor：创建样本时样本扭曲函数中用来决定像素是有效还是作为背景过滤的基本值，因为操作的是灰度图，所以这个值的范围是 0 ~ 255。</li>
<li>-bgthresh：决定背景掩码的实际取值，范围为 bgcolor - bgthresh  ~ bgcolor + bgthresh。</li>
<li>-inv、-randinv：样本生成时，是否需要反向或随机反向，这个在车牌数字识别中比较常用，比如说白底黑字的车牌和蓝底白字的车牌，两者生成的样本是相反的，前者数字是黑色，后者数字是白色。</li>
<li>-maxidev：一个用于生成前景（有效像素区域）灰度值的常数值，实际样本的前景灰度值会根据这个参数结合随机数产生多种不同的灰度值。</li>
<li>-maxxangle、-maxyangle、-maxzangle：使用 -img 选项创建样本才会生效，是指对于样本图片的在各方向上扭曲的最大弧度，一般我们直接使用默认值，效果较好。</li>
<li>-show：样本创建时，是否显示一个窗口显示每一个生成的样本图片。</li>
<li>-w、-h：要创建样本图片的尺寸，这个参数要和后面训练时的一致，不然会报错。</li>
</ul>
<p>基于以上选项，根据需求可以写一个批处理文件执行 opencv_createsamples.exe，这样不用每次设置这么多参数，我的批处理文件是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opencv_createsamples.exe -img pos/pos1.png -bgcolor 255 -bgthresh 0 -vec pos1.vec -num 1200 -w 20 -h 20 </span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p>这里我创建了 1200 个正样本，执行后在当前目录下生成了一个名为 pos1.vec 的文件，这就是我们要的正样本描述文件了。接着我把 pos1.png 换成了 pos2.png，pos1.vec 换成了 pos2.vec 来生成第二张 logo 图片的描述文件，也能正常执行。</p>
<h2 id="负样本描述文件"><a href="#负样本描述文件" class="headerlink" title="负样本描述文件"></a>负样本描述文件</h2><p>对于负样本，不需要正样本那样麻烦，只需要创建一个后缀为 .txt 或者 .dat 的文本文件，里面的内容就是图片名，每一张图片的信息占一行，不能有空行。由于负样本较多，所以可以写一个小程序用来生成这个文件，非常简单，下图是我的负样本描述文件：</p>
<img src="/2017/06/26/opencv/img05.png">
<p><br></p>
<h1 id="开始训练分类器"><a href="#开始训练分类器" class="headerlink" title="开始训练分类器"></a>开始训练分类器</h1><p>一切准备就绪后就可以开始训练分类器了，同样我们先看看程序，打开 cmd，目录切换到 /opencv/build/x64/vc14/bin/，输入 opencv_traincascade.exe，可以看到如下选项：</p>
<img src="/2017/06/26/opencv/img06.png">
<ul>
<li>-data：指定最后生成的分类器模型存放的目录。</li>
<li>-vec：指定正样本描述文件，这个是上个步骤产生的 .vec 文件。</li>
<li>-bg：指定负样本描述文件，这个是上个步骤产生的 .txt 或 .dat 文件。</li>
<li>-numPos：在每一级训练中使用的正样本数量。这个参数和之前生成 .vec 时指定 -num 的有关，经过我的各种实验，发现设为 85% 最为合适，各方面都能达到平衡。</li>
<li>-numNeg：在每一级训练中使用的负样本数量。这个值可以设置大于真正的负样本图像数目，因为程序会自动从负样本图像中切割出和正样本大小一致的图像块，这个参数一般设置为正样本数目的 3 倍。</li>
<li>-numStages：训练级数，推荐使用 15 ~ 20，级数越高，需要的样本数量越多，当然耗时越长，检测效果越好。</li>
<li>-precalcValBufSize：缓存大小，用于存储预先计算的特征值，一般使用默认值。</li>
<li>-precalcIdxBufSize：缓存大小，用于存储预先计算的特征索引，一般使用默认值。</li>
<li>-baseFormatSave：仅在使用 Haar 特征时有效，如果指定，级联分类器将以老格式存储。</li>
<li>-numThreads：训练时开启的线程数，一般使用默认值。</li>
<li>-stageType：级联算法，一般使用默认值。</li>
<li>-featureType：提取的特征算法，包括 Haar、Lbp 和 Hog（Hog 好像不能用），一般使用 Lbp 特征，速度最快。</li>
<li>-w、-h：训练的窗口大小，必须和之前创建样本时指定的一致，一般我们设为 20 <em> 20，这个参数太大会影响训练速度，20 </em> 20 是保证好的检测效果的同时能保证速度的一个值。</li>
<li>-bt：Boosted 分类器的类型，一般使用默认值。</li>
<li>-minHitRate：最小命中率，即训练目标的准确度。假设每一级训练 1000 个正样本，如果指定为 0.999，那么有一个样本会被认为是不合格的样本。一般根据正样本的数量进行设置，我的原则是让正样本逃出一个作为负样本。</li>
<li>-maxFlaseAlarmRate：最大虚警（误检率），每层训练到小于这个值时结束，进入下一级训练，一般使用默认值。</li>
<li>-mode：如果使用 Haar 特征，则这个选项生效，用于指定特征类型。</li>
</ul>
<p>理解完了各个选项的含义后，我们可以写出这样一个批处理文件（之后我把 pos1.vec 换成了 pos2.vec 重新训练，从而产生两个模型文件）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opencv_traincascade.exe -data data -vec pos1.vec -bg neg/neg.txt -numPos 1000 -numNeg 3000 -numStages 15 -featureType LBP -w 20 -h 20 -minHitRate 0.999 -maxFalseAlarmRate 0.5</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p>执行这个批处理文件，如果顺利，会在 /data/ 目录下生成很多文件，如下图：</p>
<img src="/2017/06/26/opencv/img07.png">
<p><br>这里的 cascade.xml 就是最终训练好的模型文件，其他的都是中间文件。这里会发现一个问题，明明我指定的是训练到 15 级，为什么中间文件只到 stage5 呢？其实我在训练中抛出了这样一个警告：</p>
<img src="/2017/06/26/opencv/img08.png">
<p><br>这个是告诉你已经达到了需要的虚拟率，训练已经是最好的效果，再往下并不会取的更好的效果。产生这个的原因一般就是样本数量不够，尝试增大正负样本是最好的解决办法。当然，可以通过修改参数（增大 minHitRate 或 减少 maxFlaseAlarmRate）增加训练级数，但不推荐，可能会影响检测效果。</p>
<h1 id="物体识别"><a href="#物体识别" class="headerlink" title="物体识别"></a>物体识别</h1><p>到了这里，麻烦的步骤可以说已经过去了，只需要使用训练好的文件即可。主要是用到 OpenCV 中的 CascadeClassifier 这个类，我以 Java 为例，将代码和注释贴出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化级联分类器，读入 cascade.xml 文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initCascadeClassifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    File cascadeFile = <span class="keyword">new</span> File(getDir(<span class="string">"cascade"</span>, Context.MODE_PRIVATE), <span class="string">"cascade.xml"</span>);</span><br><span class="line">    FileOutputStream os = <span class="keyword">new</span> FileOutputStream(cascadeFile);</span><br><span class="line">    InputStream is = getResources().openRawResource(R.raw.cascade);</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">int</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      os.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">    is.close();</span><br><span class="line">    os.close();</span><br><span class="line">    classifier = <span class="keyword">new</span> CascadeClassifier(cascadeFile.getAbsolutePath());</span><br><span class="line">    <span class="keyword">if</span> (classifier.empty()) &#123;</span><br><span class="line">      classifier = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cascadeFile.delete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是摄像头每一帧的回调函数，会把每一帧的 Mat 对象传递出来</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mat <span class="title">onCameraFrame</span><span class="params">(CameraBridgeViewBase.CvCameraViewFrame inputFrame)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取图像矩阵</span></span><br><span class="line">  Mat rgba = inputFrame.rgba();</span><br><span class="line">  Mat gray = inputFrame.gray();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对灰度图进行直方图均衡化</span></span><br><span class="line">  Imgproc.equalizeHist(gray, gray);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行多尺度检测，检测到的目标矩阵存储在 objects 中</span></span><br><span class="line">  MatOfRect objects = <span class="keyword">new</span> MatOfRect();</span><br><span class="line">  <span class="keyword">if</span> (classifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">// 需要注意的是第三、四、六个参数，这些参数非常敏感，对结果的影响也很大，需要自行调整为最佳参数</span></span><br><span class="line">	<span class="comment">// 第三个参数：表示在前后两次相继的扫描中，搜索窗口的比例系数。默认为 1.1，即每次搜索窗口依次扩大 10%</span></span><br><span class="line">	<span class="comment">// 第四个参数：表示构成检测目标的相邻矩形的最小个数，默认为 3，如果发现检测的结果太多，可以尝试慢慢增大这个参数，反之减小</span></span><br><span class="line">	<span class="comment">// 第六个参数：每次检测的最小窗口，设置太小会影响检测速度，太大不容易检测出来</span></span><br><span class="line">    classifier.detectMultiScale(gray, objects, <span class="number">1.1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="keyword">new</span> Size(<span class="number">100</span>, <span class="number">100</span>), <span class="keyword">new</span> Size());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历结果画圆，圈出每一个检测到的结果</span></span><br><span class="line">  Rect[] rects = objects.toArray();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rects.length; i++) &#123;</span><br><span class="line">    Imgproc.circle(rgba, <span class="keyword">new</span> Point(rects[i].x + rects[i].width / <span class="number">2</span>, rects[i].y + rects[i].height / <span class="number">2</span>), (rects[i].width / <span class="number">2</span> + rects[i].height / <span class="number">2</span>) / <span class="number">2</span>, <span class="keyword">new</span> Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rgba;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><p>直接把我的程序截图贴出来：</p>
<img src="/2017/06/26/opencv/img09.jpg">
<p><br><br><img src="/2017/06/26/opencv/img10.jpg"></p>
<p><br>从图中可以看出来识别非常精确，当然这是经过我的各种调参达到的效果。</p>
<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>未来会越来越好，技术会越来越好，生活会越来越好，感情会越来越好！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/16/Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="金梧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="金梧的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/Algorithm/" itemprop="url">常用基础算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-16T00:00:00+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/16/Algorithm/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/05/16/Algorithm/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/05/16/Algorithm/" class="leancloud_visitors" data-flag-title="常用基础算法总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在总结自己的一些理论知识，发现还是有很多地方不够理解，总结到基础算法时发现很多东西都忘了，所以写下这篇博客，当是笔记吧，知识都是东拼西凑加上自己的理解写的！</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>冒泡排序通过重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来，直到没有再需要交换的元素为止（对 n 个项目需要 O(n<sup>2</sup>) 的比较次数）。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<img src="/2017/05/16/Algorithm/img01.png">
<p><br></p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>最差时间复杂度：O(n<sup>2</sup>)</li>
<li>最优时间复杂度：O(n)</li>
<li>平均时间复杂度：O(n<sup>2</sup>)</li>
<li>空间复杂度：总共 O(n)，需要辅助空间 O(1)</li>
</ul>
<h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] numbers) &#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  	 <span class="comment">// 每一轮比完后，最大的元素肯定是在最后，所以下一轮后面的元素不用参与比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numbers.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="comment">// 相邻的元素比较，如果前者大于后者，则交换两者位置，这样，小的元素会往上冒泡</span></span><br><span class="line">      <span class="keyword">if</span> (numbers[j] &gt; numbers[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = numbers[j];</span><br><span class="line">        numbers[j] = numbers[j + <span class="number">1</span>];</span><br><span class="line">        numbers[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>每趟从待排序的记录中选出最小的元素记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。</p>
<h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li>每一轮初始化一个索引位置，索引位置逐轮增加。</li>
<li>每一轮有一个最小元素的位置，找出索引位置后面的元素的最小值，并且和索引位置交换。</li>
<li>开始下一轮，直到没有元素比较。</li>
</ul>
<img src="/2017/05/16/Algorithm/img02.png">
<p><br></p>
<h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>在简单选择排序过程中，所需移动记录的次数比较少。最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。　 </li>
<li>最坏情况下，即待排序记录初始状态是按第一条记录最大，之后的记录从小到大顺序排列，则需要移动记录的次数最多为 3(n - 1）。</li>
<li>简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关。 </li>
<li>当 i = 1 时，需进行 n - 1 次比较；当 i = 2 时，需进行 n - 2 次比较；依次类推，共需要进行的比较次数是 (n - 1) + (n - 2) + … + 2 + 1 = n(n - 1) / 2，即进行比较操作的时间复杂度为 O(n<sup>2</sup>)，进行移动操作的时间复杂度为O(n)。　</li>
<li>简单选择排序是不稳定排序。</li>
</ul>
<h3 id="Java-实现-1"><a href="#Java-实现-1" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] numbers) &#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 初始化最小元素的指向位置</span></span><br><span class="line">    <span class="keyword">int</span> min = i;</span><br><span class="line">    <span class="comment">// 从索引位置开始，数组后面的找出最小的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numbers.length; j++) &#123;</span><br><span class="line">      <span class="comment">// 找出最小的元素，则 min 总是指向这一轮最小元素的位置</span></span><br><span class="line">      <span class="keyword">if</span> (numbers[j] &lt; numbers[min]) &#123;</span><br><span class="line">        min = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这一轮索引位置不是最小元素的指向位置则交换，进入下一轮，此时这一轮最小元素排在了最前面</span></span><br><span class="line">    <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">      temp = numbers[min];</span><br><span class="line">      numbers[min] = numbers[i];</span><br><span class="line">      numbers[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，是稳定的排序方法。</p>
<p>把待排序的纪录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的纪录插入完为止，得到一个新的有序序列。</p>
<h3 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li>从第二个元素开始遍历，每一轮有一个要插入的值。</li>
<li>将要插入的值和已经排好序的数组逐一比较，如果前者小于后者中的某个元素，则该元素向后移动一位，这里会留一个空白位置。</li>
<li>然后在空白位置插入之前保存的插入值，这样新的有序数组就排好了，每一轮新增一个元素。</li>
</ul>
<img src="/2017/05/16/Algorithm/img03.png">
<p><br></p>
<h3 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>空间复杂度：O(1)</li>
<li>平均时间复杂度：O(n<sup>2</sup>)</li>
<li>最差时间复杂度：反序，需要移动 n * (n - 1) / 2 个元素，运行时间为 O(n<sup>2</sup>)</li>
<li>最好时间复杂度：正序，不需要移动元素，运行时间为 O(n)</li>
</ul>
<h3 id="Java-实现-2"><a href="#Java-实现-2" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] numbers) &#123;</span><br><span class="line">  <span class="comment">// 从数组的第二个元素开始遍历要插入的值，因为第一个元素肯定是排好序的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 每一轮要插入的值（作为暂存）</span></span><br><span class="line">    <span class="keyword">int</span> insertValue = numbers[i];</span><br><span class="line">    <span class="comment">// 指向要插入的位置的前一个位置</span></span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果插入值小于已经排好序的数组中的一个元素，则该元素向后移一位，等于留了一个空白位置</span></span><br><span class="line">    <span class="comment">// 这里不用担心数据丢失，因为要插入的值已经保存起来了</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; numbers[j] &gt; insertValue) &#123;</span><br><span class="line">      numbers[j + <span class="number">1</span>] = numbers[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将插入值插入指定位置</span></span><br><span class="line">    numbers[j + <span class="number">1</span>] = insertValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>直接插入排序中要把插入元素与已有序序列元素依次进行比较，效率非常低。</p>
<p>折半插入排序，也叫二分插入排序，使用使用折半查找的方式寻找插入点的位置，可以减少比较的次数，但移动的次数不变，时间复杂度和空间复杂度和直接插入排序一样，在元素较多的情况下能提高查找性能。</p>
<p>直接插入排序是，比较一个后移一个。折半插入排序是，先找到位置（使用折半查找算法），然后一起移动。</p>
<h3 id="实现思路-3"><a href="#实现思路-3" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li>从第二个元素开始遍历，每一轮有一个要插入的值。</li>
<li>将要插入的值和已经排好序的数组的中间元素比较，以已经排好序的数组的中间元素为分界，确定待插元素是在已经排好序的数组的左边还是右边。</li>
<li>如果是在其左边，则以该左边序列为当前查找序列，右边也类似。</li>
<li>递归地处理新序列，直到当前查找序列的长度小于 1 时查找过程结束。</li>
</ul>
<img src="/2017/05/16/Algorithm/img04.png">
<p><br></p>
<h3 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>时间复杂度：折半插入排序适合记录数较多的场景，与直接插入排序相比，折半插入排序在寻找插入位置上面所花的时间大大减少，但是折半插入排序在记录移动次数方面和直接插入排序是一样的，所以其时间复杂度为 O(n<sup>2</sup>)。 </li>
<li>其次，折半插入排序的记录比较次数与初始序列无关。因为每趟排序折半寻找插入位置时，折半次数是一定的，折半一次就要比较一次，所以比较次数也是一定的。</li>
<li>空间复杂度：O(1)</li>
<li>折半插入排序是一种稳定的排序算法。</li>
</ul>
<h3 id="Java-实现-3"><a href="#Java-实现-3" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] numbers) &#123;</span><br><span class="line">  <span class="comment">// 从数组的第二个元素开始遍历要插入的值，因为第一个元素肯定是排好序的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 每一轮要插入的值（作为暂存）</span></span><br><span class="line">    <span class="keyword">int</span> insertValue = numbers[i];</span><br><span class="line">    <span class="comment">// 排好序的数组的起始下标和结束下标</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找的排好序的数组至少有一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">      <span class="comment">// 找到排好序的数组的中间元素位置</span></span><br><span class="line">      <span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 如果要插入的值大于中间元素，表示要插入的位置在中间元素右边，则起始下标等于中间元素位置加一，反之结束下标等于中间元素位置减一</span></span><br><span class="line">      <span class="keyword">if</span> (insertValue &gt; numbers[middle]) &#123;</span><br><span class="line">        low = middle + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        high = middle - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里，起始下标等于结束下标，即 low = high，所以只要把从 low + 1 到 i - 1 的位置整体向后移</span></span><br><span class="line">    <span class="comment">// 不用担心数据丢失，因为第 i 位就是要插入的值，已经保存了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; low; j--) &#123;</span><br><span class="line">      numbers[j + <span class="number">1</span>] = numbers[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将插入值插入指定位置</span></span><br><span class="line">    numbers[low] = insertValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>快速排序是对冒泡排序的一种改进，又称划分交换排序。快速排序使用分治法策略来把一个序列分为两个子序列，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序是在实际中最常用的一种排序算法，速度快，效率高。就像名字一样，快速排序是最优秀的一种排序算法。</p>
<h3 id="实现思路-4"><a href="#实现思路-4" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li>在待排序的元素任取一个元素作为基准（通常选第一个元素，但最好的选择方法是从待排序元素中随机选取一个作为基准），称为基准元素。</li>
<li>将待排序的元素进行分区，比基准元素大的元素放在它的右边，比其小的放在它的左边，这一步骤称为分区操作。</li>
<li>对左右两个分区重复以上步骤直到所有元素都是有序的。</li>
<li>每一次递归其实就是把选中的基准元素放在排序的中间。</li>
</ul>
<img src="/2017/05/16/Algorithm/img05.png">
<p><br></p>
<h3 id="性能分析-4"><a href="#性能分析-4" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>当分区选取的基准元素为待排序元素中的最大或最小值时，为最坏的情况，时间复杂度和直接插入排序的一样，移动次数达到最大值，此时时间复杂为 O(n<sup>2</sup>) 。</li>
<li>当分区选取的基准元素为待排序元素中的中值时，为最好的情况，时间复杂度为 O(nlog<sub>2</sub>n)。</li>
<li>快速排序的空间复杂度为 O(log<sub>2</sub>n)。</li>
<li>当待排序元素类似 [6, 1, 3, 7, 3] 且基准元素为 6 时，经过分区，形成 [1, 3, 3, 6, 7]，两个 3 的相对位置发生了改变，所以快速排序是一种不稳定排序。</li>
</ul>
<h3 id="Java-实现-4"><a href="#Java-实现-4" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">  <span class="keyword">int</span> left = low;</span><br><span class="line">  <span class="keyword">int</span> right = high;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// 待排序的第一个元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = numbers[left];</span><br><span class="line">    <span class="comment">// 从左右两边交替扫描，直到 left = right</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="comment">// 从右往左扫描，找到第一个比基准元素小的元素</span></span><br><span class="line">      <span class="keyword">while</span> (left &lt; right &amp;&amp; numbers[right] &gt;= pivot) &#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到这个元素后放在左边</span></span><br><span class="line">      numbers[left] = numbers[right];</span><br><span class="line">      <span class="comment">// 从左往右扫描，找到第一个比基准元素大的元素</span></span><br><span class="line">      <span class="keyword">while</span> (left &lt; right &amp;&amp; numbers[left] &lt;= pivot) &#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/// 找到这个元素后放在右边</span></span><br><span class="line">      numbers[right] = numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 left = right，基准元素位于序列正中间</span></span><br><span class="line">    <span class="keyword">int</span> middle = left;</span><br><span class="line">    numbers[middle] = pivot;</span><br><span class="line">    <span class="comment">// 对基准元素左边的元素进行相同的流程（递归）</span></span><br><span class="line">    sort(numbers, low, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对基准元素右边的进行递归相同的流程（递归）</span></span><br><span class="line">    sort(numbers, middle + <span class="number">1</span>, high);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>从表中的第一个或者是最后一个记录开始，逐个的将表中记录的关键字和给定值进行比较。若某个记录的关键字和给定值相等，则查找成功；若表中所有记录的关键字和给定值都不相等，则查找失败。</p>
<h3 id="Java-实现-5"><a href="#Java-实现-5" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers[i] == key) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>又叫二分查找，它的前提条件是在一个有序的序列中。首先确定待查记录所在的区间，然后逐步的缩小范围区间直到找到或者找不到该记录为止。与数学中的二分法一样。 </p>
<h3 id="Java-实现-6"><a href="#Java-实现-6" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = numbers.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="comment">// 找到中间位置</span></span><br><span class="line">    <span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 如果要查找的元素比中间位置小，则区间高位在中间位置的左边，反之区间地位在中间位置的右边，如果相等，则查找结束</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; numbers[middle]) &#123;</span><br><span class="line">      high = middle - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; numbers[middle]) &#123;</span><br><span class="line">      low = middle + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p>斐波那契查找是根据斐波那契序列的特点对表进行分割。假设表中记录的个数比某个斐波那契数小 1，即 n = F<sub>n</sub> − 1，然后将给定值和表中第 F<sub>n-1</sub> 个记录的关键字进行比较。若相等，则查找成功；若给定关键字 &lt; 表中第 F<sub>n-1</sub> 个记录的关键字，则继续在表中从第一个记录到第 F<sub>n-1</sub> − 1 个记录之间查找；若给定关键字 &gt; 表中第 F<sub>n-1</sub> 个记录的关键字，则继续在自 F<sub>n-1</sub> + 1 至 Fn − 1 的子表中查找。 </p>
<p>斐波那契查找也是需要针对有序序列。这种查找用到了斐波那契数列的一个性质：前一个数除以相邻的后一个数，比值无限接近黄金分割。</p>
<p>查找的精髓在于采用最接近查找长度的斐波那契数值来确定拆分点。举个例子来讲，现有长度为 9 的数组，要对它进行拆分，对应的斐波那契数列（长度先随便取，只要最大数大于 9 即可） {1，1，2，3，5，8，13，21，34}，不难发现，大于 9 且最接近 9 的斐波那契数值是 f[6] = 13，为了满足所谓的黄金分割，所以它的第一个拆分点应该就是 f[6] 的前一个值 f[5] = 8，即待查找数组的第8个数，对应到下标就是 array[7]，依次类推。</p>
<h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确定需要的斐波那契数，其数值一定要大于数组的长度</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (getFibonacci(i) &gt; numbers.length) &#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开始查找</span></span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = numbers.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> middle = low + getFibonacci(i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (numbers[middle] == key) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; numbers[middle]) &#123;</span><br><span class="line">      high = middle - <span class="number">1</span>;</span><br><span class="line">      i--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; numbers[middle]) &#123;</span><br><span class="line">      low = middle + <span class="number">1</span>;</span><br><span class="line">      i -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到第n个斐波那契数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    res = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> second = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      res = first + second;</span><br><span class="line">      first = second;</span><br><span class="line">      second = res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/25/WXAndNodeJS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="金梧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="金梧的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/25/WXAndNodeJS/" itemprop="url">微信小程序 + Node.js + MongoDB + VPS(Linux)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-25T00:00:00+08:00">
                2017-04-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/25/WXAndNodeJS/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/04/25/WXAndNodeJS/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/04/25/WXAndNodeJS/" class="leancloud_visitors" data-flag-title="微信小程序 + Node.js + MongoDB + VPS(Linux)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这段时间由于公司没有项目做，确实闲出蛋了，于是给自己找了点事做。听说最近 Node.js 火得不行，我也赶一波潮流，照着<a href="https://nodejs.org/" target="_blank" rel="noopener">官方网站</a>学习了下，对于有编程基础的同学来说入门还是比较容易的。</p>
<p>学习新东西还是比较有激情的吧，很快把 Node.js、Express（一个基于 Node.js 的 Web 应用框架）和 MongoDB 都大概学了一下，恰好这个时间我准备开始健身，就想着做一个小应用来管理自己每天的饮食、训练和身体数据。由于考虑到本地 App 需要适应不同平台，前端选择了最新微信新出的一个公众服务平台：小程序。</p>
<p>好了，随便唠两句，还是进入正题吧，一个一个来。</p>
<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>首先得在电脑上安装 Node.js 环境，直接去<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>下载就好了，注意最好下载最近的 LTS 版本，比较稳定，我的版本是 v6.10.1。</p>
<p>关于 Node.js 的基本知识和用法就不介绍了，<a href="http://nodejs.cn/api/" target="_blank" rel="noopener">中文官网</a>上都有，直接上 Express。</p>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="http://www.expressjs.com.cn" target="_blank" rel="noopener">Express</a> 是一个简洁而灵活的 Node.js Web 应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站，它有一套健壮的特性，可用于开发单页、多页和混合Web应用。</p>
<h3 id="安装-Express-代码生成器"><a href="#安装-Express-代码生成器" class="headerlink" title="安装 Express 代码生成器"></a>安装 Express 代码生成器</h3><p>对于一个 Express 应用来说，其代码结构大致一样（框架的统一性），所以官方随着 Express 一起也发布了一个代码生成器，打开终端，输入如下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g express-generator</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NPM 是随同 Node.js 一起安装的包管理工具，可以解决 Node.js 代码部署的很多问题，通俗地讲就是用来下载 Node.js 代码库的。</p>
</blockquote>
<p>上面的 -g 参数表示全局安装，即在任何目录下都可以使用 express-generator 模块。</p>
<h3 id="新建一个工程"><a href="#新建一个工程" class="headerlink" title="新建一个工程"></a>新建一个工程</h3><p>打开终端，输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ express <span class="_">-e</span> fighting          // <span class="_">-e</span> 是指定页面渲染模版为 ejs，默认为 jade</span><br></pre></td></tr></table></figure>
<p>你会发现在当前目录下生成了一个 figting 目录，这是 Express 给我们生成了一个基本的框架代码，哇，刺激！下面咱们来看看这些框架代码有什么东西。</p>
<h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><p>直接通过文本编辑器打开，可以看到如下目录结构：</p>
<img src="/2017/04/25/WXAndNodeJS/img01.png">
<p><br>app.js：工程的主控文件，或者说是进行全局配置的地方。</p>
<p>package.json：存储着工程的信息及模块依赖，当在 dependencies 中添加依赖的模块时，运行 npm install，NPM 会检查当前目录下的 package.json，并自动安装所有指定的模块。</p>
<p>node_modules：存放 package.json 中安装的模块，当你在 package.json 添加依赖的模块并安装后，存放在这个文件夹下。</p>
<p>public：存放 image、css、js 等文件。</p>
<p>routes：存放路由文件。</p>
<p>views：存放视图文件或者说模版文件。</p>
<p>bin：存放可执行文件。</p>
<h4 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h4><p>直接贴上所有代码，解释都放在注释中了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> favicon = <span class="built_in">require</span>(<span class="string">'serve-favicon'</span>);</span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用路由文件</span></span><br><span class="line"><span class="keyword">var</span> index = <span class="built_in">require</span>(<span class="string">'./routes/index'</span>);</span><br><span class="line"><span class="keyword">var</span> users = <span class="built_in">require</span>(<span class="string">'./routes/users'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个 express 实例</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置视图文件夹为 views，__dirname 为全局变量，存储当前正在执行的脚本所在的目录（这里也可以用"./views"）</span></span><br><span class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置视图渲染模版为 ejs</span></span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各种中间件的添加</span></span><br><span class="line">app.use(logger(<span class="string">'dev'</span>));</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 public 文件夹为存放静态文件的目录</span></span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'public'</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由控制器</span></span><br><span class="line">app.use(<span class="string">'/'</span>, index);</span><br><span class="line">app.use(<span class="string">'/users'</span>, users);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获 404 错误，并转发到错误处理器</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not Found'</span>);</span><br><span class="line">  err.status = <span class="number">404</span>;</span><br><span class="line">  next(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开发环境下的错误处理器，将错误信息渲染 error 模版并显示到浏览器中</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  res.locals.message = err.message;</span><br><span class="line">  res.locals.error = req.app.get(<span class="string">'env'</span>) === <span class="string">'development'</span> ? err : &#123;&#125;;</span><br><span class="line">  res.status(err.status || <span class="number">500</span>);</span><br><span class="line">  res.render(<span class="string">'error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure>
<h4 id="bin-www"><a href="#bin-www" class="headerlink" title="bin/www"></a>bin/www</h4><p>这个 www 文件可以理解为程序的入口，同样直接看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'../app'</span>);</span><br><span class="line"><span class="keyword">var</span> debug = <span class="built_in">require</span>(<span class="string">'debug'</span>)(<span class="string">'fighting:server'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 http 服务器，并监听 3000 端口</span></span><br><span class="line"><span class="keyword">var</span> port = normalizePort(process.env.PORT || <span class="string">'3000'</span>);</span><br><span class="line">app.set(<span class="string">'port'</span>, port);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(app);</span><br><span class="line">server.listen(port);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">server.on(<span class="string">'error'</span>, onError);</span><br><span class="line">server.on(<span class="string">'listening'</span>, onListening);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否在运行时指定端口</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizePort</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> port = <span class="built_in">parseInt</span>(val, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isNaN</span>(port)) &#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (port &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> port;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error.syscall !== <span class="string">'listen'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> bind = <span class="keyword">typeof</span> port === <span class="string">'string'</span></span><br><span class="line">    ? <span class="string">'Pipe '</span> + port</span><br><span class="line">    : <span class="string">'Port '</span> + port;</span><br><span class="line">  <span class="keyword">switch</span> (error.code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'EACCES'</span>:</span><br><span class="line">      <span class="built_in">console</span>.error(bind + <span class="string">' requires elevated privileges'</span>);</span><br><span class="line">      process.exit(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'EADDRINUSE'</span>:</span><br><span class="line">      <span class="built_in">console</span>.error(bind + <span class="string">' is already in use'</span>);</span><br><span class="line">      process.exit(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口成功</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onListening</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> addr = server.address();</span><br><span class="line">  <span class="keyword">var</span> bind = <span class="keyword">typeof</span> addr === <span class="string">'string'</span></span><br><span class="line">    ? <span class="string">'pipe '</span> + addr</span><br><span class="line">    : <span class="string">'port '</span> + addr.port;</span><br><span class="line">  debug(<span class="string">'Listening on '</span> + bind);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="routes-index-js"><a href="#routes-index-js" class="headerlink" title="routes/index.js"></a>routes/index.js</h4><p>路由文件，来看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径是"/"，渲染一个名叫 index 的文件作为返回内容（目录在 app.js 中指定过），并且传递了一个 title 参数</span></span><br><span class="line"><span class="comment">// 如果是想返回 json 数据，这里改成 res.json(&#123;&#125;); 即可</span></span><br><span class="line"><span class="comment">// 这里是 get 请求，如果是提供给客户端使用的 Api 接口，也可以使用 post 请求</span></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123; <span class="attr">title</span>: <span class="string">'Express'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于请求参数的解释：</span></span><br><span class="line"><span class="comment">// req.query ： 处理 get 请求，获取 get 请求参数</span></span><br><span class="line"><span class="comment">// req.params ： 处理 /:xxx 形式的 get 或 post 请求，获取请求参数</span></span><br><span class="line"><span class="comment">// req.body ： 处理 post 请求，获取 post 请求体</span></span><br><span class="line"><span class="comment">// req.param() ： 处理 get 和 post 请求，但查找优先级由高到低为 req.params → req.body → req.query</span></span><br></pre></td></tr></table></figure>
<h4 id="views-index-ejs"><a href="#views-index-ejs" class="headerlink" title="views/index.ejs"></a>views/index.ejs</h4><p>前端真正显示的内容，这里很简单，和一般的 Html 基本相似，只是使用了 &lt;%= title% &gt; 这个东西，其实这就是把之前传递过来的 title 变量全部替换成了 Express 而已。</p>
<blockquote>
<p> 关于模版引擎不作详解，这篇博客的 Node.js 重点在后台服务。</p>
</blockquote>
<h3 id="启动第一个工程"><a href="#启动第一个工程" class="headerlink" title="启动第一个工程"></a>启动第一个工程</h3><p>打开终端，cd 到 fighting 目录，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br></pre></td></tr></table></figure>
<p>如果控制台没有报什么错误的话，就已经启动成功了。打开浏览器，输入 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a>，可以看到如下页面：</p>
<img src="/2017/04/25/WXAndNodeJS/img02.png">
<p><br>到了这里，写一些基于 Express 的路由接口应该没什么问题了，但是一般的后台服务程序不可能一直把数据存在内存里面吧，所以使用数据库进行数据的管理是必不可少的，下面咱们来看看和 Node.js 形影不离的 MongoDB～～～</p>
<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>MongoDB 是一个基于分布式文件存储的 NoSQL（非关系型数据库）的一种，由 C++ 语言编写，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 支持的数据结构非常松散，是类似 json 的 bjson 格式，因此可以存储比较复杂的数据类型。MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p>
<p>MongoDB 没有关系型数据库中行和表的概念，不过有类似的文档和集合的概念。文档是 MongoDB 最基本的单位，每个文档都会以唯一的 _id 标识，文档的属性为 key/value 的键值对形式，文档内可以嵌套另一个文档，因此可以存储比较复杂的数据类型。集合是许多文档的总和，一个数据库可以有多个集合，一个集合可以有多个文档。</p>
<p>下面是一个 MongoDB 文档的示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attr">"_id"</span> : ObjectId( <span class="string">"4f7fe8432b4a1077a7c551e8"</span> ),</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"nswbmw"</span>,</span><br><span class="line">  <span class="attr">"age"</span> : <span class="number">22</span>,</span><br><span class="line">  <span class="attr">"email"</span> : [ <span class="string">"xxx@126.com"</span>, <span class="string">"xxx@gmail.com"</span> ],</span><br><span class="line">  <span class="attr">"family"</span> : &#123;</span><br><span class="line">    "mother" : &#123; ... &#125;,</span><br><span class="line">    "father" : &#123; ... &#125;,</span><br><span class="line">    <span class="string">"sister : &#123;</span></span><br><span class="line">      "name" : "miaomiao",</span><br><span class="line">      "age" : 27,</span><br><span class="line">      "email" : "xxx@163.com",</span><br><span class="line">      "family" : &#123;</span><br><span class="line">        "mother" : &#123; ... &#125;,</span><br><span class="line">        "father" : &#123; ... &#125;,</span><br><span class="line">        <span class="string">"brother : &#123; ... &#125;,</span></span><br><span class="line">        "husband" : &#123; ... &#125;,</span><br><span class="line">        "son" : &#123; ... &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多有关 MongoDB 的知识可以查阅：<a href="http://www.mongodb.org/" target="_blank" rel="noopener">http://www.mongodb.org/</a>。</p>
<h2 id="安装-MongoDB"><a href="#安装-MongoDB" class="headerlink" title="安装 MongoDB"></a>安装 MongoDB</h2><p>安装 MongoDB 很简单,去<a href="https://www.mongodb.com/download-center#community" target="_blank" rel="noopener">官网</a>下载对应系统的 MongoDB 压缩包解压即可。</p>
<h2 id="启动-MongoDB"><a href="#启动-MongoDB" class="headerlink" title="启动 MongoDB"></a>启动 MongoDB</h2><p>刚安装上是没办法使用 MongoDB 的，需要启动服务。打开终端，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mongod --dbpath (你的数据路径) --logpath (你的日志路径)</span><br></pre></td></tr></table></figure>
<p>这里容易发生出现两个小问题。一个是启动失败返回 100 错误码，这里需要把 /data 目录下的 mongod.lock 删除，再次启动；另一个是默认端口被占用，那么修改端口或者结束占用端口的进程便可以解决！</p>
<blockquote>
<p>端口号也可以指定，使用 -port 命令，MongoDB 的默认端口号是 27017。</p>
</blockquote>
<p>这里一般不会有什么问题，运行后再执行 mongo，会发现进入了 Mongo 的命令控制台，这样表明启动成功啦！</p>
<p>启动后，当然是要玩儿了！这里列一些比较常用的命令吧：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ db                                   // 查看当前使用的数据库名称，默认是 <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">$ show dbs                             // 列出当前连接的 MongoDB 的所有数据库名称</span><br><span class="line"></span><br><span class="line">$ use (db)                             // 切换数据库，若数据库不存在，则创建</span><br><span class="line"></span><br><span class="line">$ show collections                     // 列出当前数据库存在的集合名称</span><br><span class="line"></span><br><span class="line">$ db.(collection).find().pretty()      // 列出指定集合名称的所有文档数据，并且格式化</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用命令行可能对于某些人不太习惯（事实上大部分人都不会习惯），这里我使用了一款客户端软件 MongoChef，非常好用！</p>
</blockquote>
<h2 id="使用-Mongoose-模块"><a href="#使用-Mongoose-模块" class="headerlink" title="使用 Mongoose 模块"></a>使用 Mongoose 模块</h2><p>对于 Node.js 操作 MongoDB 有很多框架，这里推荐一个 Mongoose，特点是简单好用，给一个<a href="https://cnodejs.org/topic/504b4924e2b84515770103dd" target="_blank" rel="noopener">入门网站</a>。</p>
<h3 id="配置-mongoose-模块"><a href="#配置-mongoose-模块" class="headerlink" title="配置 mongoose 模块"></a>配置 mongoose 模块</h3><p>使用前当然是要安装 mongoose 模块了，cd 到 fighting 目录，输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install mongoose --save    // --save 指定安装时同时写入 package.json 的 dependencies 标签下</span><br></pre></td></tr></table></figure>
<h3 id="写代码1"><a href="#写代码1" class="headerlink" title="写代码1"></a>写代码1</h3><p>安装后当然是要使用了，在 fighting 目录下建立一个目录 models，专门存放所有和数据库有关的对象。首先写一个连接对象，名为 db.js，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">mongoose.Promise = <span class="built_in">Promise</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接数据库，数据库名为 fighting，端口号为 27017</span></span><br><span class="line"><span class="keyword">var</span> db = mongoose.createConnection(<span class="string">'mongodb://localhost:27017/fighting'</span>);</span><br><span class="line"><span class="comment">// 监听连接的情况，并在控制台输出响应内容</span></span><br><span class="line">db.on(<span class="string">'error'</span>, (error) =&gt; <span class="built_in">console</span>.log(<span class="string">'连接数据库错误 =&gt; '</span> + error));</span><br><span class="line">db.on(<span class="string">'open'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'连接数据库成功'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = db;</span><br></pre></td></tr></table></figure>
<p>上面中的代码有一个 Promise，简单解释下，这是 ES6 用来传递异步操作消息对象，简单点说就是可以把耗时操作放在后台线程中执行，给一个学习网站吧——<a href="http://www.jianshu.com/p/063f7e490e9a" target="_blank" rel="noopener">Javascript 中的神器——Promise</a>。</p>
<p>接着咱们创建一个实体对象 user.js，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">var</span> db = <span class="built_in">require</span>(<span class="string">'./db'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userSchema = <span class="keyword">new</span> mongoose.Schema(</span><br><span class="line">  &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    password: <span class="built_in">String</span>,</span><br><span class="line">    head: <span class="built_in">String</span>,</span><br><span class="line">    nick: <span class="built_in">String</span>,</span><br><span class="line">    registerTime: <span class="built_in">String</span>,</span><br><span class="line">    lastLoginTime: <span class="built_in">String</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = db.model(<span class="string">'user'</span>, userSchema);</span><br></pre></td></tr></table></figure>
<p>很简单，就是指定名为 user 文档中的字段和类型，然后导出这个模块。</p>
<blockquote>
<p>mongoose 有一个有趣的东西，就是你指定的文档名他会变为复数形式，比如这里的 user 会变成 users！</p>
</blockquote>
<h3 id="写代码2"><a href="#写代码2" class="headerlink" title="写代码2"></a>写代码2</h3><p>连接对象和实体对象都创建完成了，接下来是不是要对其进行增删改查了呢？</p>
<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个要插入的数据库对象</span></span><br><span class="line"><span class="keyword">var</span> userEntity = &#123;<span class="attr">username</span>: <span class="string">'admin'</span>, <span class="attr">password</span>: <span class="string">'123456'</span>, <span class="attr">nick</span>: <span class="string">'管理员'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 user 模块并插入</span></span><br><span class="line"><span class="keyword">var</span> userModel = <span class="built_in">require</span>(<span class="string">'../models/user'</span>);</span><br><span class="line">userModel.create(userEntity).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里返回的 user 便是插入成功的对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除条件，这里指定 username</span></span><br><span class="line"><span class="keyword">var</span> userEntity = &#123;<span class="attr">username</span>: username&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 user 模块并删除</span></span><br><span class="line"><span class="keyword">var</span> userModel = <span class="built_in">require</span>(<span class="string">'../models/user'</span>);</span><br><span class="line">userModel.delete(userEntity).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 删除成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义修改的数据库对象</span></span><br><span class="line"><span class="keyword">var</span> userEntity = &#123;<span class="attr">username</span>: <span class="string">'admin'</span>, <span class="attr">password</span>: <span class="string">'123'</span>, <span class="attr">nick</span>: <span class="string">'金梧'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 user 模块并更新</span></span><br><span class="line"><span class="keyword">var</span> userModel = <span class="built_in">require</span>(<span class="string">'../models/user'</span>);</span><br><span class="line">userModel.update(userEntity).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 更新成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义修改的数据库对象，这里指定 username</span></span><br><span class="line"><span class="keyword">var</span> userEntity = &#123;<span class="attr">username</span>: <span class="string">'admin'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 user 模块</span></span><br><span class="line"><span class="keyword">var</span> userModel = <span class="built_in">require</span>(<span class="string">'../models/user'</span>);</span><br><span class="line"><span class="comment">// 找列表</span></span><br><span class="line">userModel.find(userEntity).then(<span class="function"><span class="params">users</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里返回的 users 便是查找成功的对象</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 找唯一对象</span></span><br><span class="line">userModel.findOne(userEntity).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里返回的 user 便是查找成功的对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>关于 MongoDB 以及如何在 Node.js 中使用就简单介绍到这里，如果有兴趣，去官网看文档是最好的方式。</p>
<h1 id="动手写项目"><a href="#动手写项目" class="headerlink" title="动手写项目"></a>动手写项目</h1><p>有了上面的基础之后，就可以开始写项目了。之前说过想做一个关于健身数据管理的小应用，那么首先是需要把客户端需要的接口先写出来，直接开干！</p>
<h2 id="需要哪些接口"><a href="#需要哪些接口" class="headerlink" title="需要哪些接口"></a>需要哪些接口</h2><p>由于客户端的功能很简单，仅仅是一个用户每天的数据需要显示和上传，那么只需要五个接口：用户数据字段获取、用户注册、用户登录、获取数据、上传数据。</p>
<h3 id="用户数据字段获取"><a href="#用户数据字段获取" class="headerlink" title="用户数据字段获取"></a>用户数据字段获取</h3><p>为什么会有这个接口？</p>
<p>用户数据指的是用户每天针对身体、训练及饮食情况的具体数据，比如体重、做俯卧撑的情况等，这些字段如果直接在客户端写死会很不灵活，如果想增加新的字段需要更新客户端。而如果通过在后台配置这些字段，前台动态获取，这样能解决因新增字段过于频繁更新客户端的麻烦。</p>
<p>那应该怎么做呢？首先应该定义好一个配置文件，里面放置前台需要的字段。新建 files 目录，在目录下新建一个文件，名为 fighting.config，写入下面的配置信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"身体情况"</span>,</span><br><span class="line">    <span class="attr">"items"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"称重(kg)"</span>,</span><br><span class="line">        <span class="attr">"hint"</span>: <span class="string">"请输入重量（无任何负重）"</span>,</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"weight"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">""</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"饮食情况"</span>,</span><br><span class="line">    <span class="attr">"items"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"早餐"</span>,</span><br><span class="line">        <span class="attr">"hint"</span>: <span class="string">"请输入早餐"</span>,</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"breakfast"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">""</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"午餐"</span>,</span><br><span class="line">        <span class="attr">"hint"</span>: <span class="string">"请输入午餐"</span>,</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"noon"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">""</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"晚餐"</span>,</span><br><span class="line">        <span class="attr">"hint"</span>: <span class="string">"请输入晚餐"</span>,</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"dinner"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">""</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"运动情况"</span>,</span><br><span class="line">    <span class="attr">"items"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"跑步"</span>,</span><br><span class="line">        <span class="attr">"hint"</span>: <span class="string">"请输入跑步时间和里程"</span>,</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"run"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">""</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"杠铃卧推"</span>,</span><br><span class="line">        <span class="attr">"hint"</span>: <span class="string">"请输入组数和每组个数"</span>,</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"wotui"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">""</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"杠铃推举"</span>,</span><br><span class="line">        <span class="attr">"hint"</span>: <span class="string">"请输入组数和每组个数"</span>,</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"tuiju"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">""</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这里只列出了一小部分，也只是最简单的定义，对每个字段还进行了类别的划分。有了配置文件之后，便可以写出对应的接口了，在 routes 目录下新建 config.js 文件，写入代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/getFightingConfig'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 读取对应的配置文件，并返回给客户端</span></span><br><span class="line">  <span class="keyword">var</span> config = fs.readFileSync(<span class="string">'./files/fighting.config'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  res.json(&#123;<span class="attr">status</span>: <span class="number">200</span>, <span class="attr">data</span>: <span class="built_in">JSON</span>.parse(config)&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>
<p>这里的路径指定了 /getFightingConfig，那么可以通过访问 <a href="http://localhost:3000/getFightingConfig/" target="_blank" rel="noopener">http://localhost:3000/getFightingConfig/</a> 获取对应的数据（关于如何运行代码上面讲过了，之后不再赘述）。</p>
<h3 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h3><p>还记得之前使用 mongoose 定义的一个 user 对象吧，直接拿来使用，新建 register.js 文件，写入代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> userModel = <span class="built_in">require</span>(<span class="string">'../models/user'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/register'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> username = req.query.username;</span><br><span class="line">  <span class="keyword">var</span> password = req.query.password;</span><br><span class="line">  <span class="keyword">var</span> nick = req.query.nick;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数检查</span></span><br><span class="line">  <span class="keyword">if</span> (username == <span class="literal">null</span>) &#123;</span><br><span class="line">    res.json(&#123;<span class="attr">status</span>: <span class="number">201</span>, <span class="attr">msg</span>: <span class="string">'缺少参数username'</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (password == <span class="literal">null</span>) &#123;</span><br><span class="line">    res.json(&#123;<span class="attr">status</span>: <span class="number">201</span>, <span class="attr">msg</span>: <span class="string">'缺少参数password'</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nick == <span class="literal">null</span>) &#123;</span><br><span class="line">    res.json(&#123;<span class="attr">status</span>: <span class="number">201</span>, <span class="attr">msg</span>: <span class="string">'缺少参数nick'</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getUser(username, user =&gt; &#123;</span><br><span class="line">    <span class="comment">// 检查用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">      res.json(&#123;<span class="attr">status</span>: <span class="number">201</span>, <span class="attr">msg</span>: <span class="string">'该用户已存在'</span>&#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确注册</span></span><br><span class="line">    <span class="keyword">var</span> userEntity = &#123;<span class="attr">username</span>: username, <span class="attr">password</span>: password, <span class="attr">nick</span>: nick, <span class="attr">registerTime</span>: utils.getDateTime()&#125;;</span><br><span class="line">    userModel.create(userEntity).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">      res.json(&#123;<span class="attr">status</span>: <span class="number">200</span>, <span class="attr">data</span>: user&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">username, callback</span>) </span>&#123;</span><br><span class="line">  userModel.findOne(&#123;<span class="attr">username</span>: username&#125;).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    callback(user);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>
<p>这里代码也是很简单，首先获取客户端传入的参数，检查其是否齐全。然后先通过 username 参数从数据库查询，如果存在这个用户告诉客户端不能注册，否则往数据库里面插入一条用户数据，成功后通知客户端注册成功。这样一个注册接口也写好了！</p>
<p>接下来可以顺利地写下用户登录、获取数据和上传数据的接口，都是对数据库的增删改查，非常地简单～～～</p>
<h2 id="有一个小坑：Https"><a href="#有一个小坑：Https" class="headerlink" title="有一个小坑：Https"></a>有一个小坑：Https</h2><p>本人在完成后台一系列的流程后，对接微信小程序时发现：如果创建项目时指定了 AppID（必须指定AppID才能审核、发布），那么访问的接口必须是 Https 协议，并且要把服务器的地址配置在其后台才能使用。所以，之前上面使用的基于 Http 协议的服务需要改动才能供微信小程序使用，这里方法有很多，可以使用 OpenSSL，也可以去网上找。这里我使用了阿里云的证书服务，免费、简单、快速，给一个<a href="https://segmentfault.com/a/1190000008398220" target="_blank" rel="noopener">教程链接</a>！</p>
<h2 id="远程部署项目"><a href="#远程部署项目" class="headerlink" title="远程部署项目"></a>远程部署项目</h2><p>当配置完 Https 协议的证书和相关代码后，接下来需要把项目部署在真正的服务器上面。</p>
<p>对于个人开发者而言，服务器不需要太好，所以我使用的是一个名叫<a href="https://bandwagonhost.com" target="_blank" rel="noopener">搬瓦工</a>的 VPS（虚拟专用服务器），很便宜，而且速度不错，没事挂点自己的小服务在上面是非常好的！</p>
<h3 id="拷贝项目"><a href="#拷贝项目" class="headerlink" title="拷贝项目"></a>拷贝项目</h3><p>有了服务器之后，然后把该装的环境都装上，接着就是要把项目都拷贝到服务器上去，有几种做法：</p>
<p>1、通过 SSH 远程连接 VPS，通过拷贝命令拷贝文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p (port) root@(IP)                 // 连接指定 IP 指定端口号的 VPS，以 root 权限进入</span><br><span class="line"></span><br><span class="line">$ scp root@(IP):/home/A /home/B           // 将本地 home/A 拷贝至目标主机的 home，并命名为 B</span><br></pre></td></tr></table></figure>
<p>2、通过 Git 上传代码，服务器下载。这种方式较推荐，需要在服务器实现安装 Git Shell。</p>
<p>3、在服务器搭建 FTP 服务，通过 FTP 客户端直接操作文件。本人用的就是这种方式，另外用的客户端软件灰常好用，推荐 FileZilla，下面是 FileZilla 连接上服务器后的界面，是不是很直观呢！</p>
<img src="/2017/04/25/WXAndNodeJS/img03.png">
<p><br></p>
<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>接下来是要在服务器运行项目，和本地运行不同的是，项目需要在服务器的后台一直运行，不能说是一退出就没了！另外有可能端口号被占用，这里介绍几条需要用到的命令（ Linux 命令）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># forever start（可执行程序名）           // 永远将指定程序运行在后台</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pkill (进程名)                        // 杀死指定进程名的进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lsof -i:(port)                       // 列出指定端口被占用的进程情况</span></span><br></pre></td></tr></table></figure>
<p>至此，关于后台的所有流程都走完了，终于要到微信小程序出场了，很激动有木有！</p>
<h1 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h1><p>按照惯例，这里是不是应该介绍一把，算了，自己去<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">微信公众平台</a>了解吧，很详细！</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先得去微信公众平台网站注册一个小程序账号，按照流程一步一步来，没有什么坑要过，注意类型写个人的就好了！</p>
<p>接着创建一个小程序，也是按照其流程一步一步走，创建成功后会得到一个 AppID，之后会有用。</p>
<p>然后下载并安装微信 web 开发工具，打开后点击“添加项目”，会有如下界面：</p>
<img src="/2017/04/25/WXAndNodeJS/img04.png">
<p><br>填入 AppID 和项目相关信息，进入后便开始写代码。</p>
<h2 id="玩转开发工具"><a href="#玩转开发工具" class="headerlink" title="玩转开发工具"></a>玩转开发工具</h2><p>关于微信小程序的代码没打算介绍，因为官网上的介绍已经非常全面了，而且是最新的，对着<a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=1493175676" target="_blank" rel="noopener">文档</a>学习一到两个小时就可以开始写代码了（前提是得有 Html、CSS 和 JavaScript 的基础）。这里主要来看一看开发工具怎么玩的！</p>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>这里主要是代码编辑，简单明了：</p>
<img src="/2017/04/25/WXAndNodeJS/img05.png">
<p><br>关于收起和展开需要根据自己显示的大小合适调整，另外手机型号和网络情况都可以进行选择。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>主要是页面预览和控制台相关的信息，还包括网络、内存、闪存、GPS模拟型号等信息，另外左下角还有对缓存清除的按钮：</p>
<img src="/2017/04/25/WXAndNodeJS/img06.png">
<p><br></p>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>这里主要是在代码功能编写完成后，对项目进行发布的流程之一，如下图：</p>
<img src="/2017/04/25/WXAndNodeJS/img07.png">
<p><br></p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>当代码上传成功后，进入微信公众平台-小程序-开发管理，可以看到刚刚提交的代码信息，如图：</p>
<img src="/2017/04/25/WXAndNodeJS/img08.png">
<p><br>接着要进行代码审核，点击“提交审核”，便可根据流程提交审核，需要注意的是配置的页面和类别一定要对应，不然审核会过不去。</p>
<p>大概等一到两天吧，审核通过后点击“发布”，即可在微信小程序中搜索自己的小程序啦！</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>奉上我自己的小程序吧，功能很简单，不要吐槽，哈哈哈！！！这只是第一个版本，还在升级中，UP！UP！UP！</p>
<img src="/2017/04/25/WXAndNodeJS/img09.jpg">

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/14/AndroidForUnity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="金梧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="金梧的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/14/AndroidForUnity/" itemprop="url">Android 和 Unity 交互及各种神坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-14T00:00:00+08:00">
                2017-04-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/14/AndroidForUnity/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/04/14/AndroidForUnity/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/04/14/AndroidForUnity/" class="leancloud_visitors" data-flag-title="Android 和 Unity 交互及各种神坑">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近公司请外包团队做了一款手游，临近上线需要接入公司自己渠道的账号体系（登录、注册、充值等），于是开发 SDK 和在手游中接入 SDK 又落在了我的头上。手游是用 Unity 开发的，而 SDK 是使用 Android Native，现在唯一需要解决的就是它们之间应该如何交互，接下来就把本人如何交互和交互过程中遇到的问题分享给大家。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先当然是要按照需求把 SDK 开发出来，这里我使用 Android Studio 作为开发环境。</p>
<p>由于最终 SDK 是要和 Unity 对接的，所以我把 SDK 的所有功能都单独放在了一个库模块中，主模块仅仅是调用，如图（关于 Android 开发不作介绍）：</p>
<img src="/2017/04/14/AndroidForUnity/img01.png">
<p><br>对 SDK 的功能进行测试，当本地测试通过后进行下一步。</p>
<h1 id="在-SDK-中导入-Unity-模块"><a href="#在-SDK-中导入-Unity-模块" class="headerlink" title="在 SDK 中导入 Unity 模块"></a>在 SDK 中导入 Unity 模块</h1><h2 id="Unity-简单介绍"><a href="#Unity-简单介绍" class="headerlink" title="Unity 简单介绍"></a>Unity 简单介绍</h2><p><a href="https://unity3d.com/cn/" target="_blank" rel="noopener">Unity</a> 是可以开发诸如三维视频游戏、建筑模型、三维动画等交互类内容的多平台综合游戏开发工具，具有很强大的跨平台性。在 Unity 之中编写好场景和程序之后，可以导出 Android、ios、windows phone、PC 等多个平台的版本。</p>
<h2 id="使用-unity-jar"><a href="#使用-unity-jar" class="headerlink" title="使用 unity.jar"></a>使用 unity.jar</h2><p>Unity 官方给 Android 提供了一个开发包（下载地址自行百度吧～），用以 Android 和 Unity 交互。</p>
<p>在 Android 工程中引入 unity.jar，编写一个 Activity（需要继承自 UnityPlayerActivity，我的类名是 Unity3dActivity ），这个类便是之后 Android 和 Unity 交互的核心，并且还需要在 AndroidManifest.xml 中写入如下的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">"com.gempoll.zhai8_sdk.sdk.Unity3dActivity"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:configChanges</span>=<span class="string">"fontScale|keyboard|keyboardHidden|locale|mnc|mcc|navigation|orientation|screenLayout|screenSize|smallestScreenSize|uiMode|touchscreen"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"unityplayer.UnityActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="导出-SDK-模块的-aar"><a href="#导出-SDK-模块的-aar" class="headerlink" title="导出 SDK 模块的 aar"></a>导出 SDK 模块的 aar</h2><p>当上面的流程配置完成后，编译 Android 项目，成功后可在模块下的 build/outputs/aar 目录，找到相应的 aar 包，一般来说会有 debug 版和 release版（区别在于代码压缩、混淆和应用签名），这里我直接使用了 test_sdk-release.aar。</p>
<h1 id="在Unity-中导入-SDK-模块"><a href="#在Unity-中导入-SDK-模块" class="headerlink" title="在Unity 中导入 SDK 模块"></a>在Unity 中导入 SDK 模块</h1><p>创建一个 Unity 工程，在其 Assets 目录下建立 Plugins/Android 目录，用于专门存放 Android相关的文件，将需要拷贝的文件拷贝至 Plugins/Android 目录下，如下图：</p>
<img src="/2017/04/14/AndroidForUnity/img02.png">
<p><br>至此，基本的配置完成，现在需要写代码让 Unity 和 Android “亲热”起来！</p>
<h1 id="Unity-和-Android-交互"><a href="#Unity-和-Android-交互" class="headerlink" title="Unity 和 Android 交互"></a>Unity 和 Android 交互</h1><h2 id="Unity-调用-Android"><a href="#Unity-调用-Android" class="headerlink" title="Unity 调用 Android"></a>Unity 调用 Android</h2><p>还记得之前写的一个继承自 UnityPlayerActivity 的类吧，这个类在 Unity 中代表的就是当前的界面，所以交互代码应该都是由这个类提供。</p>
<p>现在我们来写第一个方法，让 Unity 调用 Android 的 Toast 工具类的方法，在屏幕上显示一条信息。在 Unity3dActivity.java 中写下如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">u_showToast</span><span class="params">(<span class="keyword">final</span> String text)</span> </span>&#123;</span><br><span class="line">  runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Toast.makeText(Unity3dActivity.<span class="keyword">this</span>, text, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译工程，将新的 aar 包拷贝至 Unity 工程中。</p>
<blockquote>
<p>坑一：这里使用了 runOnUiThread() 进行线程切换，如果不进行切换，所有和页面相关的代码将不会被执行。</p>
</blockquote>
<p>在 Unity 工程中创建 test.cs 文件，绑定到 Unity 对象，在 Start() 方法中写入如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  AndroidJavaClass jc = <span class="keyword">new</span> AndroidJavaClass(<span class="string">"com.unity3d.player.UnityPlayer"</span>);</span><br><span class="line">  AndroidJavaObject jo = jc.GetStatic&lt;AndroidJavaObject&gt;(<span class="string">"currentActivity"</span>);</span><br><span class="line">  jo.Call(<span class="string">"u_showToast"</span>, <span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下，前两句是找到 Android 的当前界面对象（就是之前写的 Unity3dActivity.java，直接照抄），第三句使用这个对象的 Call() 方法，第一个参数便是在 Unity3dActivity.java 中写的方法名，后面的参数便是该方法对应的参数，这里是调用 Android 方法在屏幕上显示一条“test”信息。</p>
<blockquote>
<p>坑二：参数只能是字符串，传入其他类型会使方法失效。</p>
</blockquote>
<p>接着，可以使用 Unity 打包 Apk了，要记得对 Player Settings 进行配置，注意包名、版本号、最小编译版本等信息要和 AndroidManifest.xml 中的一致，如下图：</p>
<img src="/2017/04/14/AndroidForUnity/img03.png">
<p><br>接着点击 build 进行打包，你会发现报错了！</p>
<img src="/2017/04/14/AndroidForUnity/img04.png">
<p><br>此时的你心里一万头草泥马在奔跑，我尼玛搞了这么久你给我来这个？</p>
<p>别急，我们是程序员，要压抑自己的小宇宙，我们来仔细看看这些错误，其实说的就是 classes.jar 和 unity.jar 有类冲突。那么这两个东西又是什么呢？</p>
<p>unity.jar 之前说过了，是 Unity 提供给我们进行交互的。可能我们现在还不知道 classes.jar 是什么，先用解压软件打开 test_sdk.aar 一探究竟。</p>
<img src="/2017/04/14/AndroidForUnity/img05.png">
<p><br>终于看到 classes.jar 了，从图中可以看出 classes.jar 是 aar 中 java 代码的集合，但这里还有一个 libs 文件夹，点进去会发现会 unity.jar 被打包进来了，这样是不是把这个 unity.jar 删掉就可以了，咱们来试试！</p>
<blockquote>
<p>坑三：通过解压软件 aar 中的 unity.jar 删除，然后生成新的 aar，更新 Unity 工程中的 test_sdk.aar，重新打包。</p>
</blockquote>
<p>还是报错！不过貌似不是之前的错误了，证明删除 unity.jar 是正确的。</p>
<img src="/2017/04/14/AndroidForUnity/img06.png">
<p><br>这里说的是不能合并 AndroidManifest.xml 文件，这里我还是继续用解压软件打开 aar， 删除 AndroidManifest.xml 中所有所有组件配置信息，只留下了 application 标签，如下图：</p>
<img src="/2017/04/14/AndroidForUnity/img07.png">
<p><br></p>
<blockquote>
<p>坑四：删除 aar 中 AndroidManifest.xml 中的信息，但不能删除其本身！</p>
</blockquote>
<p>重新生成 aar，然后拷贝拷贝至 Unity 工程，打包等待。这里公司的电脑打包成功了，但我自己的笔记本还是报错，如下图：</p>
<img src="/2017/04/14/AndroidForUnity/img08.png">
<p><br>这个错误一看就是环境配置的问题，原因是 SDK 指定的编译工具的版本在 Unity 打包时找不到，一般是因为 Unity 版本太老了，这里给大家一个<a href="http://www.androiddevtools.cn" target="_blank" rel="noopener">下载地址</a>，下载最新的 SDK Tools，拷贝到 /sdk/tools 下面即可。</p>
<blockquote>
<p>坑五：aar 中指定的编译工具版本一定要和 Unity 指定的一致！</p>
</blockquote>
<p>当环境弄好之后再次打包，终于成功打包了！安装 Apk 后打开，会成功的打印一条“test”的消息，这里我就不贴图了。</p>
<h2 id="Android-向-Unity-发送消息"><a href="#Android-向-Unity-发送消息" class="headerlink" title="Android 向 Unity 发送消息"></a>Android 向 Unity 发送消息</h2><p>现在我们可以随意在 Unity 中调用 Android 代码了，但是还有一些应用场景需要 Android 向 Unity 发送消息（在 Java 中称为回调），该怎么做呢？</p>
<p>在 Unity 中，游戏是由 Screen 和 GameObject 构成的，所以游戏世界里的每一个物品都是 GameObject，GameObject 有一个 name 属性，用以区分不同的 GameObject。如果 Android 要向 Unity 发送消息，首先得告诉 Unity 是哪个 GameObject，所以 Android 这边要写一个方法，供 Unity 初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">u_setGameObject</span><span class="params">(String gameObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.gameObject = gameObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个成员变量 gameObject 用以存储当前 Unity 指定的 GameObject。接着，如果想主动发消息给 Unity，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnityPlayer.UnitySendMessage(gameObject, <span class="string">"onTest"</span>, <span class="string">"test"</span>);</span><br></pre></td></tr></table></figure>
<p>第一个参数表示发送游戏对象的名称，第二个参数表示对象绑定的脚本接收该消息的函数，第三个参数表示本条消息发送的字符串信息。</p>
<p>接着打开 Unity 工程，编写 test.cs：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  jo.Call(<span class="string">"u_setGameObject"</span>, gameObject.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTest</span>(<span class="params"><span class="keyword">string</span> msg</span>) </span>&#123;</span><br><span class="line">  Debug.Log(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先调用了 Android 提供的 u_setGameObject()，告知 Android 要通知的 GameObject 就是自身，然后写了一个回调函数 onTest()，和 Android 中定义的一样，这样便能接受到 Android 传过来的消息了。</p>
<p>至此，Android 和 Unity 的基本交互就 OK 了！</p>
<h1 id="其他坑货"><a href="#其他坑货" class="headerlink" title="其他坑货"></a>其他坑货</h1><p>不要以为到这里就可以地让 Android 和 Unity 快乐地么么哒了，踩坑之路还未结束～</p>
<h2 id="运行时找不到类"><a href="#运行时找不到类" class="headerlink" title="运行时找不到类"></a>运行时找不到类</h2><p>使用 Android Studio 开发的同学，肯定对 Gradle 非常的喜爱，其中有一项特性就是加载第三方库不需要再去到处找了，直接在 build.gradle 中相应的位置写上对应的包名即可，它的原理是在编译时去下载这些库文件，然后打包进 Apk 中，但是如果以这种方式生成 aar 给 Unity调用，便会在运行时抛出找不到类的错误，如下图：</p>
<img src="/2017/04/14/AndroidForUnity/img09.png">
<p><br>这里提示我找不到 EventBus 这个类，解决办法是去 Android Studio 工程中寻找对应的库文件（一定要根据工程路径寻找，不能在网上随便下载，否则版本对不上一样报错），然后将库文件拷贝至 Unity 工程中，重新打包则无问题。</p>
<blockquote>
<p>坑六：当程序出现找不到某个类的错误时，必然就是某个对应的库文件没有拷贝给 Unity。</p>
</blockquote>
<h2 id="SDK-无法使用-ViewPager"><a href="#SDK-无法使用-ViewPager" class="headerlink" title="SDK 无法使用 ViewPager"></a>SDK 无法使用 ViewPager</h2><p>这个原因还未找到，但是只要 SDK 中使用了 ViewPager 程序便会报错（虽然也是找不到类的错误，但拷贝了对应的库文件一样报错），我推测是由于 Unity 编译器还未支持此控件（可能新版本已经支持了）。</p>
<blockquote>
<p>坑七：不能使用 ViewPager。</p>
</blockquote>
<h2 id="引用第三方-jar-的坑"><a href="#引用第三方-jar-的坑" class="headerlink" title="引用第三方 jar 的坑"></a>引用第三方 jar 的坑</h2><p>如果 SDK 中还需引入第三方 jar，需注意其 jar 中有否含有出 .java 以外的文件（比如我集成夜神 SDK 时，他们将配置信息打包进了 jar 中，同样可用解压软件打开查看），如果有，则需要把那些文件单独再拷贝到 Unity 工程中（原 jar 可以不删除）。</p>
<blockquote>
<p>坑八：引用的第三方 jar 若含有非 .java 文件等资源文件，则需单独拷贝。</p>
</blockquote>
<h2 id="第三方资源"><a href="#第三方资源" class="headerlink" title="第三方资源"></a>第三方资源</h2><p>如果 SDK 中引入了第三方资源，如 assets 资源等，则需要把 aar 中的 assets 删除，并且把 assets 拷贝至 Unity 工程中。</p>
<blockquote>
<p>坑九：引用第三方资源时，需把 aar 文件中对应的资源删除，然后单独拷贝。</p>
</blockquote>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>关于 Android 如何与 Unity 交互已经介绍完了，这些都是本人在开发过程中遇到的问题，希望对大家有点用处。</p>
<p>PS：纯原创，转载说明出处，谢谢！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/12/AndroidVersion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="金梧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="金梧的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/12/AndroidVersion/" itemprop="url">关于 compileSdkVersion，minSdkVersion 和 targetSdkVersion 的选择</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-12T00:00:00+08:00">
                2017-03-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/12/AndroidVersion/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/03/12/AndroidVersion/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/03/12/AndroidVersion/" class="leancloud_visitors" data-flag-title="关于 compileSdkVersion，minSdkVersion 和 targetSdkVersion 的选择">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>相信大家都已经转移到 <a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">Android Studio</a> 上开发 Android App 了，但可能对于其构建工具 <a href="https://developer.android.com/studio/build/index.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">Gradle</a> 不熟悉，对其中的 compileSdkVersion，minSdkVersion 和 targetSdkVersion 更加傻傻分不清楚，那么本篇文章将给你理清这些东西。</p>
<h1 id="Android-系统版本对应的-API-等级"><a href="#Android-系统版本对应的-API-等级" class="headerlink" title="Android 系统版本对应的 API 等级"></a>Android 系统版本对应的 API 等级</h1><p>直接上表，是从官网上找到的：<a href="http://source.android.com/source/build-numbers.html" target="_blank" rel="noopener">http://source.android.com/source/build-numbers.html</a></p>
<table>
<thead>
<tr>
<th>Code name</th>
<th>Version</th>
<th>API level</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nougat</td>
<td>7.1</td>
<td>API level 25</td>
</tr>
<tr>
<td>Nougat</td>
<td>7.0</td>
<td>API level 24</td>
</tr>
<tr>
<td>Marshmallow</td>
<td>6.0</td>
<td>API level 23</td>
</tr>
<tr>
<td>Lollipop</td>
<td>5.1</td>
<td>API level 22</td>
</tr>
<tr>
<td>Lollipop</td>
<td>5.0</td>
<td>API level 21</td>
</tr>
<tr>
<td>KitKat</td>
<td>4.4 - 4.4.4</td>
<td>API level 19</td>
</tr>
<tr>
<td>Jelly Bean</td>
<td>4.3.x</td>
<td>API level 18</td>
</tr>
<tr>
<td>Jelly Bean</td>
<td>4.2.x</td>
<td>API level 17</td>
</tr>
<tr>
<td>Jelly Bean</td>
<td>4.1.x</td>
<td>API level 16</td>
</tr>
<tr>
<td>Ice Cream Sandwich</td>
<td>4.0.3 - 4.0.4</td>
<td>API level 15, NDK 8</td>
</tr>
<tr>
<td>Ice Cream Sandwich</td>
<td>4.0.1 - 4.0.2</td>
<td>API level 14, NDK 7</td>
</tr>
<tr>
<td>Honeycomb</td>
<td>3.2.x</td>
<td>API level 13</td>
</tr>
<tr>
<td>Honeycomb</td>
<td>3.1</td>
<td>API level 12, NDK 6</td>
</tr>
<tr>
<td>Honeycomb</td>
<td>3.0</td>
<td>API level 11</td>
</tr>
<tr>
<td>Gingerbread</td>
<td>2.3.3 - 2.3.7</td>
<td>API level 10</td>
</tr>
<tr>
<td>Gingerbread</td>
<td>2.3 - 2.3.2</td>
<td>API level 9, NDK 5</td>
</tr>
<tr>
<td>Froyo</td>
<td>2.2.x</td>
<td>API level 8, NDK 4</td>
</tr>
<tr>
<td>Eclair</td>
<td>2.1</td>
<td>API level 7, NDK 3</td>
</tr>
<tr>
<td>Eclair</td>
<td>2.0.1</td>
<td>API level 6</td>
</tr>
<tr>
<td>Eclair</td>
<td>2.0</td>
<td>API level 5</td>
</tr>
<tr>
<td>Donut</td>
<td>1.6</td>
<td>API level 4, NDK 2</td>
</tr>
<tr>
<td>Cupcake</td>
<td>1.5</td>
<td>API level 3, NDK 1</td>
</tr>
<tr>
<td>(node code name)</td>
<td>1.1</td>
<td>API level 2</td>
</tr>
<tr>
<td>(node code name)</td>
<td>1.0</td>
<td>API level 1</td>
</tr>
</tbody>
</table>
<h1 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h1><p>compileSdkVersion 告诉 Gradle 用哪个 Android SDK 版本编译你的应用。使用任何新添加的 API 就需要使用对应等级的 Android SDK。</p>
<p>需要强调的是修改 compileSdkVersion 不会改变运行时的行为。当你修改了 compileSdkVersion 的时候，可能会出现新的编译警告、编译错误，但新的 compileSdkVersion 不会被包含到 APK 中：它纯粹只是在编译的时候使用。</p>
<p>因此强烈推荐总是使用最新的 SDK 进行编译。在现有代码上使用新的编译检查可以获得很多好处，避免新弃用的 API ，并且为使用新的 API 做好准备。</p>
<blockquote>
<p>注意，如果使用 <a href="https://developer.android.com/topic/libraries/support-library/index.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">Support Library</a>，那么使用最新发布的 Support Library 就需要使用最新的 SDK 编译。例如，要使用 23.1.1 版本的 Support Library，compileSdkVersion 就必需至少是 23（大版本号要一致！）。通常，新版的 Support Library 随着新的系统版本而发布，它为系统新增加的 API 和新特性提供兼容性支持。</p>
</blockquote>
<h1 id="minSdkVersion"><a href="#minSdkVersion" class="headerlink" title="minSdkVersion"></a>minSdkVersion</h1><p>如果 compileSdkVersion 设置为可用的最新 API，那么 minSdkVersion 则是应用可以运行的最低要求。minSdkVersion 是 Google Play 商店用来判断用户设备是否可以安装某个应用的标志之一。</p>
<p>在开发时 minSdkVersion 也起到一个重要角色：<a href="https://developer.android.com/studio/write/lint.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">lint</a> 默认会在项目中运行，它在你使用了高于 minSdkVersion  的 API 时会警告你，帮你避免调用不存在的 API 的运行时问题。如果只在较高版本的系统上才使用某些 API，通常使用运行时检查系统版本的方式解决。</p>
<p>请记住，你所使用的库，如 <a href="https://developer.android.com/topic/libraries/support-library/features.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">Support Library</a> 或 <a href="https://developers.google.com/android/guides/overview?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">Google Play services</a>，可能有他们自己的 minSdkVersion。你的应用设置的 minSdkVersion 必需大于等于这些库的 minSdkVersion。例如有三个库，它们的 minSdkVersion 分别是 4, 7 和 9，那么你的 minSdkVersion 必需至少是 9 才能使用它们。在少数情况下，你仍然想用一个比你应用的 minSdkVersion 还高的库（处理所有的边缘情况，确保它只在较新的平台上使用），你可以使用 <a href="http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog#TOC-tools:overrideLibrary-marker" target="_blank" rel="noopener">tools:overrideLibrary</a> 标记，但请做彻底的测试！</p>
<p>当你决定使用什么 minSdkVersion 时候，你应该参考当前的 <a href="https://developer.android.com/about/dashboards/index.html" target="_blank" rel="noopener">Android 分布统计</a>，它显示了最近 7 天所有访问 Google Play 的设备信息。他们就是你把应用发布到 Google Play 时的潜在用户。最终这是一个商业决策问题，取决于为了支持额外 3% 的设备，确保最佳体验而付出的开发和测试成本是否值得。</p>
<p>当然，如果某个新的 API 是你整个应用的关键，那么确定 minSdkVersion 的值就比较容易了。不过要记得 14 亿设备中的 0.7％ 也是个不小的数字。</p>
<h1 id="targetSdkVersion"><a href="#targetSdkVersion" class="headerlink" title="targetSdkVersion"></a>targetSdkVersion</h1><p>三个版本号中最有趣的就是 targetSdkVersion 了。targetSdkVersion 是 Android 提供向前兼容的主要依据，在应用的 targetSdkVersion 没有更新之前系统不会应用最新的行为变化。这允许你在适应新的行为变化之前就可以使用新的 API（因为你已经更新了 compileSdkVersion 不是吗？）。</p>
<p>targetSdkVersion 所暗示的许多行为变化都记录在 <a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">VERSION_CODES</a> 文档中了，但是所有恐怖的细节也都列在每次发布的平台亮点中了，在这个 <a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog#ApiLevels" target="_blank" rel="noopener">API Level</a> 表中可以方便地找到相应的链接。</p>
<p>例如，<a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">Android 6.0 变化文档</a>中谈了 target 为 API 23 时会如何把你的应用转换到<a href="https://android-developers.googleblog.com/2015/08/building-better-apps-with-runtime.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">运行时权限模型</a>上，<a href="https://developer.android.com/about/versions/android-4.4.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog#Behaviors" target="_blank" rel="noopener">Android 4.4</a> 行为变化阐述了 target 为 API 19 及以上时使用 <a href="https://developer.android.com/reference/android/app/AlarmManager.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog#set%28int,%20long,%20android.app.PendingIntent%29" target="_blank" rel="noopener">set()</a> 和 <a href="https://developer.android.com/reference/android/app/AlarmManager.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog#setRepeating%28int,%20long,%20long,%20android.app.PendingIntent%29" target="_blank" rel="noopener">setRepeating()</a> 设置 alarm 会有怎样的行为变化。</p>
<p>由于某些行为的变化对用户是非常明显的（<a href="https://android-developers.googleblog.com/2012/01/say-goodbye-to-menu-button.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">弃用的 menu 按钮</a>，运行时权限等），所以将 target 更新为最新的 SDK 是所有应用都应该优先处理的事情。但这不意味着你一定要使用所有新引入的功能，也不意味着你可以不做任何测试就盲目地更新 targetSdkVersion，请一定在更新 targetSdkVersion 之前做测试！你的用户会感谢你的。</p>
<h1 id="Gradle-和-SDK-版本"><a href="#Gradle-和-SDK-版本" class="headerlink" title="Gradle 和 SDK 版本"></a>Gradle 和 SDK 版本</h1><p>所以设置正确的 compileSdkVersion, minSdkVersion 和 targetSdkVersion 很重要。如你所想， Gradle 和 Android Studio 都在构建系统中集成了它们。在你的模块的 build.gradle 文件中（也可以在 Android Studio 的项目结构选项中）设置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  compileSdkVersion <span class="number">23</span></span><br><span class="line">  buildToolsVersion <span class="string">"23.0.1"</span></span><br><span class="line"></span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    applicationId <span class="string">"com.example.test"</span></span><br><span class="line">    minSdkVersion <span class="number">7</span></span><br><span class="line">    targetSdkVersion <span class="number">23</span></span><br><span class="line">    versionCode <span class="number">1</span></span><br><span class="line">    versionName <span class="string">"1.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时用到的 compileSdkVersion 是和构建工具版本一起设置的 Android 设置之一。其他两个稍有不同，他们在构建变体(build variant)的那里声明。defaultConfig 是所有构建变体的基础，也是设置这些默认值的地方。你可以想象在一个更复杂的系统中，应用的某些版本可能会有不同的 minSdkVersion。</p>
<p>minSdkVersion 和 targetSdkVersion 与 compileSdkVersion 的另一个不同之处是它们会被包含进最终的 APK 文件中，如果你查看生成的 AndroidManifest.xml 文件，你会看到类似下面这样的标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:targetSdkVersion</span>=<span class="string">"23"</span> <span class="attr">android:minSdkVersion</span>=<span class="string">"7"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你在 AndroidManifest.xml 文件中手工设置，你会发现 Gradle 在构建时会忽略它们（尽管其它构建系统可能会明确依赖它们）。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>如果你按照上面示例那样配置，你会发现这三个值的关系是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</span><br></pre></td></tr></table></figure>
<p>这种直觉是合理的，如果 compileSdkVersion 是你的最大值，minSdkVersion 是最小值，那么最大值必需至少和最小值一样大且 target 必需在二者之间。</p>
<p>理想上，在稳定状态下三者的关系应该更像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minSdkVersion (lowest possible) &lt;= targetSdkVersion == compileSdkVersion (latest SDK)</span><br></pre></td></tr></table></figure>
<p>用较低的 minSdkVersion 来覆盖最大的人群，用最新的 SDK 设置 target 和 compile 来获得最好的外观和行为。</p>
<blockquote>
<p>声明：以上部分内容摘自<a href="https://medium.com/google-developers/picking-your-compilesdkversion-minsdkversion-targetsdkversion-a098a0341ebd" target="_blank" rel="noopener">Picking your compileSdkVersion, minSdkVersion, and targetSdkVersion</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/EnvironmentConstructionForMac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="金梧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="金梧的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/13/EnvironmentConstructionForMac/" itemprop="url">在 Mac 上搭建属于自己的博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-13T00:00:00+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/13/EnvironmentConstructionForMac/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/02/13/EnvironmentConstructionForMac/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/02/13/EnvironmentConstructionForMac/" class="leancloud_visitors" data-flag-title="在 Mac 上搭建属于自己的博客">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第一篇博客，文笔较烂，勿喷～～～这篇文章详细讲述如何在 Mac 环境下使用 Hexo + Github 搭建个人博客，本人也是搜索了很多教程，踩了很多的坑搭起来的。废话不多说，直接来！</p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo官网</a> 上本就有对Hexo安装及使用的详细介绍，强烈推荐。这里来讲述自己安装的亲身步骤，或有区别。</p>
<blockquote>
<p>注意：本人的三个软件版本分为为：node-v7.8.0，git-v2.9.3，hexo-v3.2.2。</p>
</blockquote>
<h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>用以生成静态页面。 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网</a> 上下载最新版，一路安装即可。</p>
<h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><p>用以将本地的 Hexo 内容提交至 Github。本人由于装有 Xcode，自带 Git，这里不再赘述。若没有安装 Xcode 请移步 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git官网</a>。</p>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>Node.js 和 Git 都安装成功后就开始安装 Hexo，终端执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>根据提示输入管理员密码（ Mac 登录密码）便开始安装，这个过程一般不会出问题，等待安装完成进行下一步。</p>
<h2 id="初始化-Hexo"><a href="#初始化-Hexo" class="headerlink" title="初始化 Hexo"></a>初始化 Hexo</h2><p>打开终端，指定想要存放数据的目录，cd 到该目录，然后执行如下命令（ hexo 是你指定的文件夹名，所有的数据都放在里面）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init hexo</span><br></pre></td></tr></table></figure>
<p>如果是正常安装完成，会有以下东东：</p>
<img src="/2017/02/13/EnvironmentConstructionForMac/img02.png">
<p><br></p>
<blockquote>
<p>注意：这里我卡住了，是由于下载 themes 文件夹中的默认主题 landscape 速度太慢了，我的解决办法是先停止终端程序，手动去 Hexo 官网下载 <a href="https://github.com/hexojs/hexo-theme-landscape.git" target="_blank" rel="noopener">landscape</a>，将里面的文件复制到 themes 中，然后再次执行初始化命令，会跳过主题下载，接下来安装就很顺利了。</p>
</blockquote>
<p>当所有文件安装完成，cd 到 hexo 目录下，执行下面的命令，安装 npm：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>接着开启 Hexo 服务器，执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s       // 或者 hexo server</span><br></pre></td></tr></table></figure>
<p>这时，打开网址 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> ，能看到 Hexo 默认主页，如下图：</p>
<img src="/2017/02/13/EnvironmentConstructionForMac/img01.png">
<p><br>至此，本地便配置好了。</p>
<h1 id="关联-Github"><a href="#关联-Github" class="headerlink" title="关联 Github"></a>关联 Github</h1><h2 id="创建-Github-仓库"><a href="#创建-Github-仓库" class="headerlink" title="创建 Github 仓库"></a>创建 Github 仓库</h2><p><a href="https://www.github.com" target="_blank" rel="noopener">登录Github</a>，新建一个仓库，名称是固定写法，[用户名].github.io，比如我的是 jinchim.github.io，这个域名就是以后我们博客的域名。</p>
<h2 id="修改本地配置文件"><a href="#修改本地配置文件" class="headerlink" title="修改本地配置文件"></a>修改本地配置文件</h2><p>在 hexo 文件夹下，打开 _config.yml 文件（可以用 vim 命令打开，这里我是用 Xcode 打开的），修改配置文件中最后面的内容，如下图：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/jinchim/jinchim.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>这里的 repository 后的地址是你的 Github 仓库地址。</p>
<blockquote>
<p>注意：在配置 _config.yml 文件时（包括 theme 中的），在所有冒号后面一定要有一个空格，再接上具体的属性值，否则 Hexo 命令会报错！</p>
</blockquote>
<h2 id="安装相关插件"><a href="#安装相关插件" class="headerlink" title="安装相关插件"></a>安装相关插件</h2><p>使用 Hexo 某些命令要安装相关插件，先后执行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo --save</span><br><span class="line"></span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h2 id="使用-Hexo-命令"><a href="#使用-Hexo-命令" class="headerlink" title="使用 Hexo 命令"></a>使用 Hexo 命令</h2><p>安装完成后就要使用 Hexo 的关键命令了，先解释下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean       // 删除 Hexo 生成在本地的静态网页文件</span><br><span class="line"></span><br><span class="line">$ hexo g           // 或者 hexo genarate，在本地生成静态网页文件，在 hexo/public 文件夹下</span><br><span class="line"></span><br><span class="line">$ hexo d           // 或者 hexo deploy，将本地静态网页文件部署到 Github 上</span><br></pre></td></tr></table></figure>
<p>这三个指令在每次文件改变时（配置文件、博客源文件等）都需要依次执行才能生效，缺一不可。当然，也有简洁的写法，生成和部署可以合并为一个指令，如下面任何一个：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g <span class="_">-d</span>        // 生成本地文件后部署</span><br><span class="line"></span><br><span class="line">$ hexo d -g        // 部署前先生成本地文件</span><br></pre></td></tr></table></figure>
<p>如果你未关联 Github 账号，输入 hexo d 命令时终端会提示要输入 Github 账号和密码，按照步骤输入即可。若输入正确，部署成功，此时打开网址 <a href="http://jinchim.github.io" target="_blank" rel="noopener">http://jinchim.github.io</a> 能看到的和打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 时的一样。</p>
<h2 id="为-Github-添加-SSH-key"><a href="#为-Github-添加-SSH-key" class="headerlink" title="为 Github 添加 SSH key"></a>为 Github 添加 SSH key</h2><p>为避免每次部署都要输入 Github 账号和密码，则需给 Github 添加一个 SSH key。</p>
<h3 id="生成-SSH-key"><a href="#生成-SSH-key" class="headerlink" title="生成 SSH key"></a>生成 SSH key</h3><p>执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure>
<p>如果存在文件 id_dsa.pub 和 id_rsa.pub，则不用生成新的 SSH key，否则要执行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"jinchim@vip.qq.com"</span></span><br></pre></td></tr></table></figure>
<p>后面的邮箱需要输入你自己的 Github 注册的邮箱地址。生成过程中要输入的全部选默认就好了（直接回车），默认会在路径 ~/.ssh/id_rsa.pub 生成 id_rsa 和 id_rsa.pub 两个文件。</p>
<h3 id="将-SSH-key添加到-Github-中"><a href="#将-SSH-key添加到-Github-中" class="headerlink" title="将 SSH key添加到 Github 中"></a>将 SSH key添加到 Github 中</h3><p>打开上一步生成的 id_rsa.pub 文件，里面的信息就是 SSH key，全部复制，然后粘贴到 Github 的添加 SSH key 页面中去即可（ Github -&gt; Setting -&gt; SSH keys ），如下图：</p>
<img src="/2017/02/13/EnvironmentConstructionForMac/img03.png">
<p><br>Title 随便填一个，Key 填写刚刚复制的内容，点击 Add SSH key。</p>
<h1 id="开始写博客"><a href="#开始写博客" class="headerlink" title="开始写博客"></a>开始写博客</h1><p>打开终端，cd 到 hexo 目录下，输入下面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"newPost"</span></span><br></pre></td></tr></table></figure>
<p>名为 newPost.md 的文件会建在目录 /hexo/source/_posts 下，为方便链接不建议掺杂汉字。然后就是对该文件进行编写，使用 Markdown 语法，这里推荐一款 <a href="https://macdown.uranusjr.com" target="_blank" rel="noopener">MacDown编辑器</a>。</p>
<p>文章编辑完成后，依次输入上面说的三个命令即可部署，我是用的简洁写法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line"></span><br><span class="line">$ hexo g <span class="_">-d</span></span><br></pre></td></tr></table></figure>
<p>至此，Mac 上搭建基于 Github 的 Hexo 博客就完成了。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>如果不喜欢默认的 landscape 主题，可以去 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网主题页</a> 去下载喜欢的主题，我这里下了一个 star 最多的 NexT 主题。</p>
<p>打开终端，cd 到 hexo 目录下，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>下载完成后在 themes 文件夹下会有一个 next 文件夹，将 hexo 目录下 _config.yml（注意不是next目录下）文件中的 theme 的名称 landscape 修改为 next，重新输入部署命令即可。</p>
<p>关于 NexT 主题的一些配置，可以去 <a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">NexT官方文档</a> 去查阅，有详细介绍。</p>
<h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><p>如果你觉得 Github 给的域名不够个性，可以绑定为自己的域名。首先，得自己去购买一个域名，推荐使用 <a href="https://sg.godaddy.com/zh/" target="_blank" rel="noopener">Godaddy</a> 或者 <a href="https://wanwang.aliyun.com" target="_blank" rel="noopener">阿里云万网</a>。</p>
<h3 id="Github-端"><a href="#Github-端" class="headerlink" title="Github 端"></a>Github 端</h3><p>在 /hexo/themes/next/source 目录下新建文件名为：CNAME 文件，注意没有后缀名！直接将自己的域名写入，如：jinichim.com。打开终端，cd 到 hexo 目录下，输入部署命令。</p>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>域名解析这里就不说了，购买域名的网站上有详细说明。这里贴出我的域名解析：</p>
<img src="/2017/02/13/EnvironmentConstructionForMac/img04.png">
<p><br>解析后访问 <a href="http://jinchim.com" target="_blank" rel="noopener">http://jinchim.com</a> 和 <a href="http://jinchim.github.io" target="_blank" rel="noopener">http://jinchim.github.io</a> 就是一样的效果了！</p>
<h2 id="关于插入图片"><a href="#关于插入图片" class="headerlink" title="关于插入图片"></a>关于插入图片</h2><p>可以使用 Markdown 外链图片，但是需要图床，每次使用得先上传，很麻烦有木有！</p>
<p>这里 Hexo 官方给了一个标签插件，只需将 _config.yml 文件中的 “post-asset-folder” 选项设为 true，每次新建博客文件时便会在同级目录下生成一个和文件名一样的文件夹，将图片放进去，假设图片名为 img.png，则可以这样使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img img.png [图片描述] %&#125;       // 图片描述是可选项</span><br></pre></td></tr></table></figure>
<p>是不是很方便呢～</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.png"
                alt="金梧" />
            
              <p class="site-author-name" itemprop="name">金梧</p>
              <p class="site-description motion-element" itemprop="description">带着敬畏之心前进。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">金梧</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'gjsjvK0i8vzDEpcnAQVSSXuM-gzGzoHsz',
        appKey: 'SsrbbC9trJjTlGP9WmIANilE',
        placeholder: '欢迎一起交流～～～',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("gjsjvK0i8vzDEpcnAQVSSXuM-gzGzoHsz", "SsrbbC9trJjTlGP9WmIANilE");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  



<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("gjsjvK0i8vzDEpcnAQVSSXuM-gzGzoHsz", "SsrbbC9trJjTlGP9WmIANilE");</script>
<script>
function showTime(Counter) {
	var query = new AV.Query(Counter);
	$(".leancloud_visitors").each(function() {
		var url = $(this).attr("id").trim();
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length == 0) {
					var content = '0 ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
					return;
				}
				for (var i = 0; i < results.length; i++) {
					var object = results[i];
					var content = object.get('time') + ' ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
				}
			},
			error: function(object, error) {
				console.log("Error: " + error.code + " " + error.message);
			}
		});

	});
}

function addCount(Counter) {
	var Counter = AV.Object.extend("Counter");
	url = $(".leancloud_visitors").attr('id').trim();
	title = $(".leancloud_visitors").attr('data-flag-title').trim();
	var query = new AV.Query(Counter);
	query.equalTo("url", url);
	query.find({
		success: function(results) {
			if (results.length > 0) {
				var counter = results[0];
				counter.fetchWhenSave(true);
				counter.increment("time");
				counter.save(null, {
					success: function(counter) {
						var content =  counter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(counter, error) {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
					}
				});
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
				newcounter.set("time", 1);
				newcounter.save(null, {
					success: function(newcounter) {
					    console.log("newcounter.get('time')="+newcounter.get('time'));
						var content = newcounter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(newcounter, error) {
						console.log('Failed to create');
					}
				});
			}
		},
		error: function(error) {
			console.log('Error:' + error.code + " " + error.message);
		}
	});
}
$(function() {
	var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else if ($('.post-title-link').length > 1) {
		showTime(Counter);
	}
}); 
</script>


</body>
</html>
